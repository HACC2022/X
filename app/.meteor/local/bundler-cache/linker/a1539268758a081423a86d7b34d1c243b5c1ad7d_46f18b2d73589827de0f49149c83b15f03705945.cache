[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Accounts = Package['accounts-base'].Accounts;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar ServiceConfiguration;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"service-configuration\":{\"service_configuration_common.js\":function module(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/service-configuration/service_configuration_common.js                                         //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nif (typeof ServiceConfiguration === 'undefined') {\n  ServiceConfiguration = {};\n} // Table containing documents with configuration options for each\n// login service\n\n\nServiceConfiguration.configurations = new Mongo.Collection('meteor_accounts_loginServiceConfiguration', {\n  _preventAutopublish: true,\n  connection: Meteor.isClient ? Accounts.connection : Meteor.connection\n}); // Leave this collection open in insecure mode. In theory, someone could\n// hijack your oauth connect requests to a different endpoint or appId,\n// but you did ask for 'insecure'. The advantage is that it is much\n// easier to write a configuration wizard that works only in insecure\n// mode.\n// Thrown when trying to use a login service which is not configured\n\nServiceConfiguration.ConfigError = function (serviceName) {\n  if (Meteor.isClient && !Accounts.loginServicesConfigured()) {\n    this.message = 'Login service configuration not yet loaded';\n  } else if (serviceName) {\n    this.message = 'Service ' + serviceName + ' not configured';\n  } else {\n    this.message = 'Service not configured';\n  }\n};\n\nServiceConfiguration.ConfigError.prototype = new Error();\nServiceConfiguration.ConfigError.prototype.name = 'ServiceConfiguration.ConfigError';\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"service_configuration_server.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/service-configuration/service_configuration_server.js                                         //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\n\n// Only one configuration should ever exist for each service.\n// A unique index helps avoid various race conditions which could\n// otherwise lead to an inconsistent database state (when there are multiple\n// configurations for a single service, which configuration is correct?)\ntry {\n  ServiceConfiguration.configurations.createIndex({\n    service: 1\n  }, {\n    unique: true\n  });\n} catch (err) {\n  console.error('The service-configuration package persists configuration in the ' + 'meteor_accounts_loginServiceConfiguration collection in MongoDB. As ' + 'each service should have exactly one configuration, Meteor ' + 'automatically creates a MongoDB index with a unique constraint on the ' + ' meteor_accounts_loginServiceConfiguration collection. The ' + 'createIndex command which creates that index is failing.\\n\\n' + 'Meteor versions before 1.0.4 did not create this index. If you recently ' + 'upgraded and are seeing this error message for the first time, please ' + 'check your meteor_accounts_loginServiceConfiguration collection for ' + 'multiple configuration entries for the same service and delete ' + 'configuration entries until there is no more than one configuration ' + 'entry per service.\\n\\n' + 'If the meteor_accounts_loginServiceConfiguration collection looks ' + 'fine, the createIndex command is failing for some other reason.\\n\\n' + 'For more information on this history of this issue, please see ' + 'https://github.com/meteor/meteor/pull/3514.\\n');\n  throw err;\n}\n\nMeteor.startup(() => {\n  var _Meteor$settings, _Meteor$settings$pack;\n\n  const settings = (_Meteor$settings = Meteor.settings) === null || _Meteor$settings === void 0 ? void 0 : (_Meteor$settings$pack = _Meteor$settings.packages) === null || _Meteor$settings$pack === void 0 ? void 0 : _Meteor$settings$pack['service-configuration'];\n  if (!settings) return;\n  Object.keys(settings).forEach(key => {\n    ServiceConfiguration.configurations.upsert({\n      service: key\n    }, {\n      $set: settings[key]\n    });\n  });\n});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nrequire(\"/node_modules/meteor/service-configuration/service_configuration_common.js\");\nrequire(\"/node_modules/meteor/service-configuration/service_configuration_server.js\");\n\n/* Exports */\nPackage._define(\"service-configuration\", {\n  ServiceConfiguration: ServiceConfiguration\n});\n\n})();\n","servePath":"/packages/service-configuration.js","sourceMap":{"version":3,"sources":["packages/service-configuration/service_configuration_common.js","packages/service-configuration/service_configuration_server.js"],"names":["ServiceConfiguration","configurations","Mongo","Collection","_preventAutopublish","connection","Meteor","isClient","Accounts","ConfigError","serviceName","loginServicesConfigured","message","prototype","Error","name","module","link","v","createIndex","service","unique","err","console","error","startup","settings","packages","Object","keys","forEach","key","upsert","$set"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAI,OAAOA,oBAAP,KAAgC,WAApC,EAAiD;AAC/CA,sBAAoB,GAAG,EAAvB;AACD,C,CAED;AACA;;;AACAA,oBAAoB,CAACC,cAArB,GAAsC,IAAIC,KAAK,CAACC,UAAV,CACpC,2CADoC,EAEpC;AACEC,qBAAmB,EAAE,IADvB;AAEEC,YAAU,EAAEC,MAAM,CAACC,QAAP,GAAkBC,QAAQ,CAACH,UAA3B,GAAwCC,MAAM,CAACD;AAF7D,CAFoC,CAAtC,C,CAOA;AACA;AACA;AACA;AACA;AAEA;;AACAL,oBAAoB,CAACS,WAArB,GAAmC,UAASC,WAAT,EAAsB;AACvD,MAAIJ,MAAM,CAACC,QAAP,IAAmB,CAACC,QAAQ,CAACG,uBAAT,EAAxB,EAA4D;AAC1D,SAAKC,OAAL,GAAe,4CAAf;AACD,GAFD,MAEO,IAAIF,WAAJ,EAAiB;AACtB,SAAKE,OAAL,GAAe,aAAaF,WAAb,GAA2B,iBAA1C;AACD,GAFM,MAEA;AACL,SAAKE,OAAL,GAAe,wBAAf;AACD;AACF,CARD;;AASAZ,oBAAoB,CAACS,WAArB,CAAiCI,SAAjC,GAA6C,IAAIC,KAAJ,EAA7C;AACAd,oBAAoB,CAACS,WAArB,CAAiCI,SAAjC,CAA2CE,IAA3C,GACE,kCADF,C;;;;;;;;;;;AC9BA,IAAIT,MAAJ;AAAWU,MAAM,CAACC,IAAP,CAAY,eAAZ,EAA4B;AAACX,QAAM,CAACY,CAAD,EAAG;AAACZ,UAAM,GAACY,CAAP;AAAS;;AAApB,CAA5B,EAAkD,CAAlD;;AAEX;AACA;AACA;AACA;AACA,IAAI;AACFlB,sBAAoB,CAACC,cAArB,CAAoCkB,WAApC,CACE;AAAEC,WAAO,EAAE;AAAX,GADF,EAEE;AAAEC,UAAM,EAAE;AAAV,GAFF;AAID,CALD,CAKE,OAAOC,GAAP,EAAY;AACZC,SAAO,CAACC,KAAR,CACE,qEACE,sEADF,GAEE,6DAFF,GAGE,wEAHF,GAIE,6DAJF,GAKE,8DALF,GAME,0EANF,GAOE,wEAPF,GAQE,sEARF,GASE,iEATF,GAUE,sEAVF,GAWE,wBAXF,GAYE,oEAZF,GAaE,qEAbF,GAcE,iEAdF,GAeE,+CAhBJ;AAkBA,QAAMF,GAAN;AACD;;AAEDhB,MAAM,CAACmB,OAAP,CAAe,MAAM;AAAA;;AACnB,QAAMC,QAAQ,uBAAGpB,MAAM,CAACoB,QAAV,8EAAG,iBAAiBC,QAApB,0DAAG,sBAA4B,uBAA5B,CAAjB;AACA,MAAI,CAACD,QAAL,EAAe;AACfE,QAAM,CAACC,IAAP,CAAYH,QAAZ,EAAsBI,OAAtB,CAA8BC,GAAG,IAAI;AACnC/B,wBAAoB,CAACC,cAArB,CAAoC+B,MAApC,CACE;AAAEZ,aAAO,EAAEW;AAAX,KADF,EAEE;AACEE,UAAI,EAAEP,QAAQ,CAACK,GAAD;AADhB,KAFF;AAMD,GAPD;AAQD,CAXD,E","file":"/packages/service-configuration.js","sourcesContent":["if (typeof ServiceConfiguration === 'undefined') {\n  ServiceConfiguration = {};\n}\n\n// Table containing documents with configuration options for each\n// login service\nServiceConfiguration.configurations = new Mongo.Collection(\n  'meteor_accounts_loginServiceConfiguration',\n  {\n    _preventAutopublish: true,\n    connection: Meteor.isClient ? Accounts.connection : Meteor.connection,\n  }\n);\n// Leave this collection open in insecure mode. In theory, someone could\n// hijack your oauth connect requests to a different endpoint or appId,\n// but you did ask for 'insecure'. The advantage is that it is much\n// easier to write a configuration wizard that works only in insecure\n// mode.\n\n// Thrown when trying to use a login service which is not configured\nServiceConfiguration.ConfigError = function(serviceName) {\n  if (Meteor.isClient && !Accounts.loginServicesConfigured()) {\n    this.message = 'Login service configuration not yet loaded';\n  } else if (serviceName) {\n    this.message = 'Service ' + serviceName + ' not configured';\n  } else {\n    this.message = 'Service not configured';\n  }\n};\nServiceConfiguration.ConfigError.prototype = new Error();\nServiceConfiguration.ConfigError.prototype.name =\n  'ServiceConfiguration.ConfigError';\n","import { Meteor } from 'meteor/meteor';\n\n// Only one configuration should ever exist for each service.\n// A unique index helps avoid various race conditions which could\n// otherwise lead to an inconsistent database state (when there are multiple\n// configurations for a single service, which configuration is correct?)\ntry {\n  ServiceConfiguration.configurations.createIndex(\n    { service: 1 },\n    { unique: true }\n  );\n} catch (err) {\n  console.error(\n    'The service-configuration package persists configuration in the ' +\n      'meteor_accounts_loginServiceConfiguration collection in MongoDB. As ' +\n      'each service should have exactly one configuration, Meteor ' +\n      'automatically creates a MongoDB index with a unique constraint on the ' +\n      ' meteor_accounts_loginServiceConfiguration collection. The ' +\n      'createIndex command which creates that index is failing.\\n\\n' +\n      'Meteor versions before 1.0.4 did not create this index. If you recently ' +\n      'upgraded and are seeing this error message for the first time, please ' +\n      'check your meteor_accounts_loginServiceConfiguration collection for ' +\n      'multiple configuration entries for the same service and delete ' +\n      'configuration entries until there is no more than one configuration ' +\n      'entry per service.\\n\\n' +\n      'If the meteor_accounts_loginServiceConfiguration collection looks ' +\n      'fine, the createIndex command is failing for some other reason.\\n\\n' +\n      'For more information on this history of this issue, please see ' +\n      'https://github.com/meteor/meteor/pull/3514.\\n'\n  );\n  throw err;\n}\n\nMeteor.startup(() => {\n  const settings = Meteor.settings?.packages?.['service-configuration'];\n  if (!settings) return;\n  Object.keys(settings).forEach(key => {\n    ServiceConfiguration.configurations.upsert(\n      { service: key },\n      {\n        $set: settings[key],\n      }\n    );\n  });\n});\n"]}}]