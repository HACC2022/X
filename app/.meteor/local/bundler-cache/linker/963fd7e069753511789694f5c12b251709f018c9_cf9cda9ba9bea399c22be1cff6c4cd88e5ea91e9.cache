[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package['modules-runtime'].meteorInstall;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modules\":{\"server.js\":function module(require){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/server.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nrequire(\"./install-packages.js\");\nrequire(\"./process.js\");\nrequire(\"./reify.js\");\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"install-packages.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/install-packages.js                                                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nfunction install(name, mainModule) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n\n  if (typeof mainModule === \"string\") {\n    // Set up an alias from /node_modules/meteor/<package>.js to the main\n    // module, e.g. meteor/<package>/index.js.\n    meteorDir[name + \".js\"] = mainModule;\n  } else {\n    // back compat with old Meteor packages\n    meteorDir[name + \".js\"] = function (r, e, module) {\n      module.exports = Package[name];\n    };\n  }\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"npm-mongo\");\ninstall(\"ecmascript-runtime\");\ninstall(\"modules-runtime\");\ninstall(\"modules-runtime-hot\");\ninstall(\"modules\", \"meteor/modules/server.js\");\ninstall(\"modern-browsers\", \"meteor/modern-browsers/modern.js\");\ninstall(\"es5-shim\");\ninstall(\"promise\", \"meteor/promise/server.js\");\ninstall(\"ecmascript-runtime-client\", \"meteor/ecmascript-runtime-client/versions.js\");\ninstall(\"ecmascript-runtime-server\", \"meteor/ecmascript-runtime-server/runtime.js\");\ninstall(\"babel-compiler\");\ninstall(\"dev-error-overlay\");\ninstall(\"hot-module-replacement\");\ninstall(\"react-fast-refresh\");\ninstall(\"ecmascript\");\ninstall(\"babel-runtime\", \"meteor/babel-runtime/babel-runtime.js\");\ninstall(\"fetch\", \"meteor/fetch/server.js\");\ninstall(\"inter-process-messaging\", \"meteor/inter-process-messaging/inter-process-messaging.js\");\ninstall(\"dynamic-import\", \"meteor/dynamic-import/server.js\");\ninstall(\"base64\", \"meteor/base64/base64.js\");\ninstall(\"ejson\", \"meteor/ejson/ejson.js\");\ninstall(\"diff-sequence\", \"meteor/diff-sequence/diff.js\");\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");\ninstall(\"id-map\", \"meteor/id-map/id-map.js\");\ninstall(\"random\", \"meteor/random/main_server.js\");\ninstall(\"mongo-id\", \"meteor/mongo-id/id.js\");\ninstall(\"ordered-dict\", \"meteor/ordered-dict/ordered_dict.js\");\ninstall(\"tracker\");\ninstall(\"mongo-decimal\", \"meteor/mongo-decimal/decimal.js\");\ninstall(\"minimongo\", \"meteor/minimongo/minimongo_server.js\");\ninstall(\"check\", \"meteor/check/match.js\");\ninstall(\"retry\", \"meteor/retry/retry.js\");\ninstall(\"callback-hook\", \"meteor/callback-hook/hook.js\");\ninstall(\"ddp-common\");\ninstall(\"reload\");\ninstall(\"socket-stream-client\", \"meteor/socket-stream-client/node.js\");\ninstall(\"ddp-client\", \"meteor/ddp-client/server/server.js\");\ninstall(\"underscore\");\ninstall(\"rate-limit\", \"meteor/rate-limit/rate-limit.js\");\ninstall(\"ddp-rate-limiter\", \"meteor/ddp-rate-limiter/ddp-rate-limiter.js\");\ninstall(\"logging\", \"meteor/logging/logging.js\");\ninstall(\"routepolicy\", \"meteor/routepolicy/main.js\");\ninstall(\"boilerplate-generator\", \"meteor/boilerplate-generator/generator.js\");\ninstall(\"webapp-hashing\");\ninstall(\"webapp\", \"meteor/webapp/webapp_server.js\");\ninstall(\"ddp-server\");\ninstall(\"ddp\");\ninstall(\"allow-deny\");\ninstall(\"mongo-dev-server\", \"meteor/mongo-dev-server/server.js\");\ninstall(\"binary-heap\", \"meteor/binary-heap/binary-heap.js\");\ninstall(\"insecure\");\ninstall(\"mongo\");\ninstall(\"reactive-var\");\ninstall(\"minifier-css\", \"meteor/minifier-css/minifier.js\");\ninstall(\"standard-minifier-css\");\ninstall(\"standard-minifier-js\");\ninstall(\"shell-server\", \"meteor/shell-server/main.js\");\ninstall(\"static-html\");\ninstall(\"typescript\");\ninstall(\"react-meteor-data\", \"meteor/react-meteor-data/index.js\");\ninstall(\"url\", \"meteor/url/server.js\");\ninstall(\"accounts-base\", \"meteor/accounts-base/server_main.js\");\ninstall(\"sha\");\ninstall(\"email\", \"meteor/email/email.js\");\ninstall(\"accounts-password\");\ninstall(\"alanning:roles\");\ninstall(\"raix:eventemitter\");\ninstall(\"tmeasday:check-npm-versions\", \"meteor/tmeasday:check-npm-versions/check-npm-versions.ts\");\ninstall(\"aldeed:collection2\", \"meteor/aldeed:collection2/collection2.js\");\ninstall(\"aldeed:schema-index\", \"meteor/aldeed:schema-index/server.js\");\ninstall(\"montiapm:meteorx\");\ninstall(\"zodern:meteor-package-versions\");\ninstall(\"montiapm:agent\");\ninstall(\"hot-code-push\");\ninstall(\"launch-screen\");\ninstall(\"autoupdate\", \"meteor/autoupdate/autoupdate_server.js\");\ninstall(\"service-configuration\");\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"process.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/process.js                                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nif (! global.process) {\n  try {\n    // The application can run `npm install process` to provide its own\n    // process stub; otherwise this module will provide a partial stub.\n    global.process = require(\"process\");\n  } catch (missing) {\n    global.process = {};\n  }\n}\n\nvar proc = global.process;\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = proc;\n      }\n    }\n  });\n} else {\n  proc.platform = \"browser\";\n  proc.nextTick = proc.nextTick || Meteor._setImmediate;\n}\n\nif (typeof proc.env !== \"object\") {\n  proc.env = {};\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nfor (var key in meteorEnv) {\n  if (hasOwn.call(meteorEnv, key)) {\n    proc.env[key] = meteorEnv[key];\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"reify.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/reify.js                                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nrequire(\"@meteorjs/reify/lib/runtime\").enable(\n  module.constructor.prototype\n);\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"@meteorjs\":{\"reify\":{\"lib\":{\"runtime\":{\"index.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor/modules/node_modules/@meteorjs/reify/lib/runtime/index.js                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nmeteorInstall({\"node_modules\":{\"simpl-schema\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/package.json                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"name\": \"simpl-schema\",\n  \"version\": \"3.0.1\",\n  \"main\": \"./dist/cjs/main.js\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"dist\":{\"cjs\":{\"main.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/main.js                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nrequire(\"./clean.js\");\r\nconst SimpleSchema_js_1 = require(\"./SimpleSchema.js\");\r\nSimpleSchema_js_1.SimpleSchema.ValidationContext = SimpleSchema_js_1.ValidationContext;\r\nexports.default = SimpleSchema_js_1.SimpleSchema;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"clean.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/clean.js                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst clone_1 = __importDefault(require(\"clone\"));\r\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\r\nconst convertToProperType_js_1 = __importDefault(require(\"./clean/convertToProperType.js\"));\r\nconst setAutoValues_js_1 = __importDefault(require(\"./clean/setAutoValues.js\"));\r\nconst SimpleSchema_js_1 = require(\"./SimpleSchema.js\");\r\nconst index_js_1 = require(\"./utility/index.js\");\r\nconst index_js_2 = require(\"./validation/typeValidator/index.js\");\r\nconst operatorsToIgnoreValue = ['$unset', '$currentDate'];\r\nfunction log(message) {\r\n    if (SimpleSchema_js_1.SimpleSchema.debug === true) {\r\n        console.debug(message);\r\n    }\r\n}\r\n/**\r\n * Cleans a document or modifier object. By default, will filter, automatically\r\n * type convert where possible, and inject automatic/default values. Use the options\r\n * to skip one or more of these.\r\n *\r\n * @param ss A SimpleSchema instance\r\n * @param doc Document or modifier to clean. Referenced object will be modified in place.\r\n * @param options Clean options\r\n * @returns The modified doc.\r\n */\r\nfunction clean(ss, doc, options = {}) {\r\n    var _a;\r\n    // By default, doc will be filtered and auto-converted\r\n    const cleanOptions = Object.assign(Object.assign({ isModifier: (0, index_js_1.looksLikeModifier)(doc), isUpsert: false }, ss._cleanOptions), options);\r\n    // Clone so we do not mutate\r\n    const cleanDoc = cleanOptions.mutate === true ? doc : (0, clone_1.default)(doc);\r\n    const mongoObject = (_a = cleanOptions.mongoObject) !== null && _a !== void 0 ? _a : new mongo_object_1.default(cleanDoc, ss.blackboxKeys());\r\n    // Clean loop\r\n    if (cleanOptions.filter === true ||\r\n        cleanOptions.autoConvert === true ||\r\n        cleanOptions.removeEmptyStrings === true ||\r\n        cleanOptions.trimStrings === true) {\r\n        const removedPositions = []; // For removing now-empty objects after\r\n        mongoObject.forEachNode(function eachNode() {\r\n            // The value of a $unset is irrelevant, so no point in cleaning it.\r\n            // Also we do not care if fields not in the schema are unset.\r\n            // Other operators also have values that we wouldn't want to clean.\r\n            if (operatorsToIgnoreValue.includes(this.operator))\r\n                return;\r\n            const gKey = this.genericKey;\r\n            if (gKey == null)\r\n                return;\r\n            let val = this.value;\r\n            if (val === undefined)\r\n                return;\r\n            let p;\r\n            // Filter out props if necessary\r\n            if ((cleanOptions.filter === true && !ss.allowsKey(gKey)) ||\r\n                (cleanOptions.removeNullsFromArrays === true && this.isArrayItem && val === null)) {\r\n                // XXX Special handling for $each; maybe this could be made nicer\r\n                if (this.position.slice(-7) === '[$each]') {\r\n                    mongoObject.removeValueForPosition(this.position.slice(0, -7));\r\n                    removedPositions.push(this.position.slice(0, -7));\r\n                }\r\n                else {\r\n                    this.remove();\r\n                    removedPositions.push(this.position);\r\n                }\r\n                log(`SimpleSchema.clean: filtered out value that would have affected key \"${gKey}\", which is not allowed by the schema`);\r\n                return; // no reason to do more\r\n            }\r\n            const outerDef = ss.schema(gKey);\r\n            const defs = outerDef === null || outerDef === void 0 ? void 0 : outerDef.type.definitions;\r\n            const def = defs === null || defs === void 0 ? void 0 : defs[0];\r\n            // Auto-convert values if requested and if possible\r\n            if (cleanOptions.autoConvert === true && defs !== undefined && def != null && !(0, index_js_2.isValueTypeValid)(defs, val, this.operator)) {\r\n                const newVal = (0, convertToProperType_js_1.default)(val, def.type);\r\n                if (newVal !== undefined && newVal !== val) {\r\n                    log(`SimpleSchema.clean: auto-converted value ${String(val)} from ${typeof val} to ${typeof newVal} for ${gKey}`);\r\n                    val = newVal;\r\n                    this.updateValue(newVal);\r\n                }\r\n            }\r\n            // Clean string values\r\n            if (typeof val === 'string') {\r\n                // Trim strings if\r\n                // 1. The trimStrings option is `true` AND\r\n                // 2. The field is not in the schema OR is in the schema with `trim` !== `false`\r\n                if (cleanOptions.trimStrings === true &&\r\n                    (def === null || def === void 0 ? void 0 : def.trim) !== false) {\r\n                    val = val.trim();\r\n                    this.updateValue(val);\r\n                }\r\n                // Remove empty strings if\r\n                // 1. The removeEmptyStrings option is `true` AND\r\n                // 2. The value is in a normal object or in the $set part of a modifier\r\n                // 3. The value is an empty string.\r\n                if (cleanOptions.removeEmptyStrings === true &&\r\n                    (this.operator == null || this.operator === '$set') &&\r\n                    val.length === 0) {\r\n                    // For a document, we remove any fields that are being set to an empty string\r\n                    this.remove();\r\n                    // For a modifier, we $unset any fields that are being set to an empty string.\r\n                    // But only if we're not already within an entire object that is being set.\r\n                    if (this.operator === '$set') {\r\n                        const matches = this.position.match(/\\[/g);\r\n                        if (matches !== null && matches.length < 2) {\r\n                            p = this.position.replace('$set', '$unset');\r\n                            mongoObject.setValueForPosition(p, '');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }, { endPointsOnly: false });\r\n        // Remove any objects that are now empty after filtering\r\n        removedPositions.forEach((removedPosition) => {\r\n            const lastBrace = removedPosition.lastIndexOf('[');\r\n            if (lastBrace !== -1) {\r\n                const removedPositionParent = removedPosition.slice(0, lastBrace);\r\n                const value = mongoObject.getValueForPosition(removedPositionParent);\r\n                if ((0, index_js_1.isEmptyObject)(value)) {\r\n                    mongoObject.removeValueForPosition(removedPositionParent);\r\n                }\r\n            }\r\n        });\r\n        mongoObject.removeArrayItems();\r\n    }\r\n    // Set automatic values\r\n    if (cleanOptions.getAutoValues === true) {\r\n        (0, setAutoValues_js_1.default)(ss.autoValueFunctions(), mongoObject, cleanOptions.isModifier || false, cleanOptions.isUpsert || false, cleanOptions.extendAutoValueContext);\r\n    }\r\n    // Ensure we don't have any operators set to an empty object\r\n    // since MongoDB 2.6+ will throw errors.\r\n    if (cleanOptions.isModifier) {\r\n        Object.keys(cleanDoc !== null && cleanDoc !== void 0 ? cleanDoc : {}).forEach((op) => {\r\n            const operatorValue = cleanDoc[op];\r\n            if (typeof operatorValue === 'object' &&\r\n                operatorValue !== null &&\r\n                (0, index_js_1.isEmptyObject)(operatorValue)) {\r\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\r\n                delete cleanDoc[op];\r\n            }\r\n        });\r\n    }\r\n    return cleanDoc;\r\n}\r\nexports.default = clean;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"clean\":{\"convertToProperType.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/clean/convertToProperType.js                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SimpleSchema_js_1 = require(\"../SimpleSchema.js\");\r\n/**\r\n * Converts value to proper type\r\n *\r\n * @param value Value to try to convert\r\n * @param type A type\r\n * @returns Value converted to type.\r\n */\r\nfunction convertToProperType(value, type) {\r\n    // Can't and shouldn't convert arrays or objects or null\r\n    if (value === null)\r\n        return value;\r\n    if (value === undefined)\r\n        return value;\r\n    if (Array.isArray(value))\r\n        return value;\r\n    if (value !== undefined &&\r\n        (typeof value === 'function' || typeof value === 'object') &&\r\n        !(value instanceof Date))\r\n        return value;\r\n    // Convert to String type\r\n    if (type === String)\r\n        return value.toString();\r\n    // Convert to Number type\r\n    if (type === Number || type === SimpleSchema_js_1.SimpleSchema.Integer) {\r\n        if (typeof value === 'string' && value.length > 0) {\r\n            // Try to convert numeric strings to numbers\r\n            const numberVal = Number(value);\r\n            if (!isNaN(numberVal))\r\n                return numberVal;\r\n        }\r\n        // Leave it; will fail validation\r\n        return value;\r\n    }\r\n    // If target type is a Date we can safely convert from either a\r\n    // number (Integer value representing the number of milliseconds\r\n    // since 1 January 1970 00:00:00 UTC) or a string that can be parsed\r\n    // by Date.\r\n    if (type === Date) {\r\n        if (typeof value === 'string') {\r\n            const parsedDate = Date.parse(value);\r\n            if (!isNaN(parsedDate))\r\n                return new Date(parsedDate);\r\n        }\r\n        if (typeof value === 'number')\r\n            return new Date(value);\r\n    }\r\n    // Convert to Boolean type\r\n    if (type === Boolean) {\r\n        if (typeof value === 'string') {\r\n            // Convert exact string 'true' and 'false' to true and false respectively\r\n            if (value.toLowerCase() === 'true')\r\n                return true;\r\n            if (value.toLowerCase() === 'false')\r\n                return false;\r\n        }\r\n        else if (typeof value === 'number' && !isNaN(value)) {\r\n            // NaN can be error, so skipping it\r\n            return Boolean(value);\r\n        }\r\n    }\r\n    // If an array is what you want, I'll give you an array\r\n    if (type === Array)\r\n        return [value];\r\n    // Could not convert\r\n    return value;\r\n}\r\nexports.default = convertToProperType;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"setAutoValues.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/clean/setAutoValues.js                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.sortAutoValueFunctions = void 0;\r\nconst AutoValueRunner_js_1 = __importDefault(require(\"./AutoValueRunner.js\"));\r\nconst getPositionsForAutoValue_js_1 = __importDefault(require(\"./getPositionsForAutoValue.js\"));\r\n/**\r\n * @method sortAutoValueFunctions\r\n * @private\r\n * @param autoValueFunctions - Array of objects to be sorted\r\n * @returns Sorted array\r\n *\r\n * Stable sort of the autoValueFunctions (preserves order at the same field depth).\r\n */\r\nfunction sortAutoValueFunctions(autoValueFunctions) {\r\n    const defaultFieldOrder = autoValueFunctions.reduce((acc, { fieldName }, index) => {\r\n        acc[fieldName] = index;\r\n        return acc;\r\n    }, {});\r\n    // Sort by how many dots each field name has, asc, such that we can auto-create\r\n    // objects and arrays before we run the autoValues for properties within them.\r\n    // Fields of the same level (same number of dots) preserve should order from the original array.\r\n    return autoValueFunctions.sort((a, b) => {\r\n        const depthDiff = a.fieldName.split('.').length - b.fieldName.split('.').length;\r\n        return depthDiff === 0\r\n            ? defaultFieldOrder[a.fieldName] - defaultFieldOrder[b.fieldName]\r\n            : depthDiff;\r\n    });\r\n}\r\nexports.sortAutoValueFunctions = sortAutoValueFunctions;\r\n/**\r\n * @method setAutoValues\r\n * @private\r\n * @param autoValueFunctions - An array of objects with func, fieldName, and closestSubschemaFieldName props\r\n * @param mongoObject\r\n * @param [isModifier=false] - Is it a modifier doc?\r\n * @param [extendedAutoValueContext] - Object that will be added to the context when calling each autoValue function\r\n *\r\n * Updates doc with automatic values from autoValue functions or default\r\n * values from defaultValue. Modifies the referenced object in place.\r\n */\r\nfunction setAutoValues(autoValueFunctions, mongoObject, isModifier, isUpsert, extendedAutoValueContext) {\r\n    const sortedAutoValueFunctions = sortAutoValueFunctions(autoValueFunctions);\r\n    sortedAutoValueFunctions.forEach(({ func, fieldName, closestSubschemaFieldName }) => {\r\n        const avRunner = new AutoValueRunner_js_1.default({\r\n            closestSubschemaFieldName,\r\n            extendedAutoValueContext,\r\n            func,\r\n            isModifier,\r\n            isUpsert,\r\n            mongoObject\r\n        });\r\n        const positions = (0, getPositionsForAutoValue_js_1.default)({\r\n            fieldName,\r\n            isModifier,\r\n            mongoObject\r\n        });\r\n        // Run the autoValue function once for each place in the object that\r\n        // has a value or that potentially should.\r\n        // @ts-expect-error\r\n        positions.forEach(avRunner.runForPosition.bind(avRunner));\r\n    });\r\n}\r\nexports.default = setAutoValues;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"AutoValueRunner.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/clean/AutoValueRunner.js                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst clone_1 = __importDefault(require(\"clone\"));\r\nconst index_js_1 = require(\"../utility/index.js\");\r\nfunction getFieldInfo(mongoObject, key) {\r\n    var _a;\r\n    const keyInfo = (_a = mongoObject.getInfoForKey(key)) !== null && _a !== void 0 ? _a : {\r\n        operator: null,\r\n        value: undefined\r\n    };\r\n    return Object.assign(Object.assign({}, keyInfo), { isSet: keyInfo.value !== undefined });\r\n}\r\nclass AutoValueRunner {\r\n    constructor(options) {\r\n        this.doneKeys = [];\r\n        this.options = options;\r\n    }\r\n    runForPosition({ key: affectedKey, operator, position, value }) {\r\n        const { closestSubschemaFieldName, extendedAutoValueContext, func, isModifier, isUpsert, mongoObject } = this.options;\r\n        // If already called for this key, skip it\r\n        if (this.doneKeys.includes(affectedKey))\r\n            return;\r\n        const fieldParentName = (0, index_js_1.getParentOfKey)(affectedKey, true);\r\n        const parentFieldInfo = getFieldInfo(mongoObject, fieldParentName.slice(0, -1));\r\n        let doUnset = false;\r\n        if (Array.isArray(parentFieldInfo.value)) {\r\n            const innerKey = affectedKey.split('.').slice(-1).pop();\r\n            if (innerKey === undefined || isNaN(Number(innerKey))) {\r\n                // parent is an array, but the key to be set is not an integer (see issue #80)\r\n                return;\r\n            }\r\n        }\r\n        const autoValueContext = Object.assign({ closestSubschemaFieldName: closestSubschemaFieldName.length > 0\r\n                ? closestSubschemaFieldName\r\n                : null, field(fName) {\r\n                return getFieldInfo(mongoObject, closestSubschemaFieldName + fName);\r\n            },\r\n            isModifier,\r\n            isUpsert, isSet: value !== undefined, key: affectedKey, operator,\r\n            parentField() {\r\n                return parentFieldInfo;\r\n            },\r\n            siblingField(fName) {\r\n                return getFieldInfo(mongoObject, fieldParentName + fName);\r\n            },\r\n            unset() {\r\n                doUnset = true;\r\n            },\r\n            value }, (extendedAutoValueContext !== null && extendedAutoValueContext !== void 0 ? extendedAutoValueContext : {}));\r\n        const autoValue = func.call(autoValueContext, mongoObject.getObject());\r\n        // Update tracking of which keys we've run autovalue for\r\n        this.doneKeys.push(affectedKey);\r\n        if (doUnset && position != null)\r\n            mongoObject.removeValueForPosition(position);\r\n        if (autoValue === undefined)\r\n            return;\r\n        // If the user's auto value is of the pseudo-modifier format, parse it\r\n        // into operator and value.\r\n        if (isModifier) {\r\n            let op;\r\n            let newValue;\r\n            if (autoValue != null && typeof autoValue === 'object') {\r\n                const avOperator = Object.keys(autoValue).find((avProp) => avProp.substring(0, 1) === '$');\r\n                if (avOperator !== undefined) {\r\n                    op = avOperator;\r\n                    newValue = autoValue[avOperator];\r\n                }\r\n            }\r\n            // Add $set for updates and upserts if necessary. Keep this\r\n            // above the \"if (op)\" block below since we might change op\r\n            // in this line.\r\n            if (op == null && position.slice(0, 1) !== '$') {\r\n                op = '$set';\r\n                newValue = autoValue;\r\n            }\r\n            if (op != null) {\r\n                // Update/change value\r\n                mongoObject.removeValueForPosition(position);\r\n                mongoObject.setValueForPosition(`${op}[${affectedKey}]`, (0, clone_1.default)(newValue));\r\n                return;\r\n            }\r\n        }\r\n        // Update/change value. Cloning is necessary in case it's an object, because\r\n        // if we later set some keys within it, they'd be set on the original object, too.\r\n        mongoObject.setValueForPosition(position, (0, clone_1.default)(autoValue));\r\n    }\r\n}\r\nexports.default = AutoValueRunner;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"getPositionsForAutoValue.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/clean/getPositionsForAutoValue.js                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\r\nconst index_js_1 = require(\"../utility/index.js\");\r\n/**\r\n * A position is a place in the object where this field exists.\r\n * If no arrays are involved, then every field/key has at most 1 position.\r\n * If arrays are involved, then a field could have potentially unlimited positions.\r\n *\r\n * For example, the key 'a.b.$.c` would have these positions:\r\n *   `a[b][0][c]`\r\n *   `a[b][1][c]`\r\n *   `a[b][2][c]`\r\n *\r\n * For this object:\r\n * {\r\n *   a: {\r\n *     b: [\r\n *       { c: 1 },\r\n *       { c: 1 },\r\n *       { c: 1 },\r\n *     ],\r\n *   },\r\n * }\r\n *\r\n * To make matters more complicated, we want to include not only the existing positions\r\n * but also the positions that might exist due to their parent object existing or their\r\n * parent object being auto-created by a MongoDB modifier that implies it.\r\n */\r\nfunction getPositionsForAutoValue({ fieldName, isModifier, mongoObject }) {\r\n    // Positions for this field\r\n    const positions = mongoObject.getPositionsInfoForGenericKey(fieldName);\r\n    // If the field is an object and will be created by MongoDB,\r\n    // we don't need (and can't have) a value for it\r\n    if (isModifier === true &&\r\n        mongoObject.getPositionsThatCreateGenericKey(fieldName).length > 0) {\r\n        return positions;\r\n    }\r\n    // For simple top-level fields, just add an undefined would-be position\r\n    // if there isn't a real position.\r\n    if (!fieldName.includes('.') && positions.length === 0) {\r\n        positions.push({\r\n            key: fieldName,\r\n            // @ts-expect-error incorrect type in mongo-object package\r\n            value: undefined,\r\n            operator: isModifier === true ? '$set' : null,\r\n            position: isModifier === true ? `$set[${fieldName}]` : fieldName\r\n        });\r\n        return positions;\r\n    }\r\n    const parentPath = (0, index_js_1.getParentOfKey)(fieldName);\r\n    const lastPart = (0, index_js_1.getLastPartOfKey)(fieldName, parentPath);\r\n    const lastPartWithBraces = lastPart.replace(/\\./g, '][');\r\n    const parentPositions = mongoObject.getPositionsInfoForGenericKey(parentPath);\r\n    if (parentPositions.length > 0) {\r\n        parentPositions.forEach((info) => {\r\n            const childPosition = `${info.position}[${lastPartWithBraces}]`;\r\n            if (positions.find((i) => i.position === childPosition) == null) {\r\n                positions.push({\r\n                    key: `${info.key}.${lastPart}`,\r\n                    // @ts-expect-error incorrect type in mongo-object package\r\n                    value: undefined,\r\n                    operator: info.operator,\r\n                    position: childPosition\r\n                });\r\n            }\r\n        });\r\n    }\r\n    else if (parentPath.slice(-2) !== '.$') {\r\n        // positions that will create parentPath\r\n        mongoObject.getPositionsThatCreateGenericKey(parentPath).forEach((info) => {\r\n            const { operator, position } = info;\r\n            let wouldBePosition;\r\n            if (operator != null) {\r\n                const next = position.slice(position.indexOf('[') + 1, position.indexOf(']'));\r\n                const nextPieces = next.split('.');\r\n                const newPieces = [];\r\n                let newKey = '';\r\n                while ((nextPieces.length > 0) && newKey !== parentPath) {\r\n                    newPieces.push(nextPieces.shift());\r\n                    newKey = newPieces.join('.');\r\n                }\r\n                newKey = `${newKey}.${fieldName.slice(newKey.length + 1)}`;\r\n                wouldBePosition = `$set[${newKey}]`;\r\n            }\r\n            else {\r\n                const lastPart2 = (0, index_js_1.getLastPartOfKey)(fieldName, parentPath);\r\n                const lastPartWithBraces2 = lastPart2.replace(/\\./g, '][');\r\n                wouldBePosition = `${position.slice(0, position.lastIndexOf('['))}[${lastPartWithBraces2}]`;\r\n            }\r\n            if (positions.find((item) => item.position === wouldBePosition) == null) {\r\n                const key = mongo_object_1.default._positionToKey(wouldBePosition);\r\n                if (key != null) {\r\n                    positions.push({\r\n                        key,\r\n                        // @ts-expect-error incorrect type in mongo-object package\r\n                        value: undefined,\r\n                        operator: operator == null ? null : '$set',\r\n                        position: wouldBePosition\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return positions;\r\n}\r\nexports.default = getPositionsForAutoValue;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"SimpleSchema.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/SimpleSchema.js                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ValidationContext = exports.SimpleSchema = exports.schemaDefinitionOptions = void 0;\r\n/* eslint-disable no-undef */\r\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\r\nconst clean_js_1 = __importDefault(require(\"./clean.js\"));\r\nconst defaultMessages_js_1 = require(\"./defaultMessages.js\");\r\nconst errors_js_1 = require(\"./errors.js\");\r\nconst expandShorthand_js_1 = __importDefault(require(\"./expandShorthand.js\"));\r\nconst SimpleSchemaGroup_js_1 = __importDefault(require(\"./SimpleSchemaGroup.js\"));\r\nconst index_js_1 = require(\"./utility/index.js\");\r\nconst ValidationContext_js_1 = __importDefault(require(\"./ValidationContext.js\"));\r\nexports.ValidationContext = ValidationContext_js_1.default;\r\n// Exported for tests\r\nexports.schemaDefinitionOptions = [\r\n    'autoValue',\r\n    'defaultValue',\r\n    'label',\r\n    'optional',\r\n    'required',\r\n    'type'\r\n];\r\nconst oneOfProps = [\r\n    'allowedValues',\r\n    'blackbox',\r\n    'custom',\r\n    'exclusiveMax',\r\n    'exclusiveMin',\r\n    'max',\r\n    'maxCount',\r\n    'min',\r\n    'minCount',\r\n    'regEx',\r\n    'skipRegExCheckForEmptyStrings',\r\n    'trim',\r\n    'type'\r\n];\r\nconst propsThatCanBeFunction = [\r\n    'allowedValues',\r\n    'exclusiveMax',\r\n    'exclusiveMin',\r\n    'label',\r\n    'max',\r\n    'maxCount',\r\n    'min',\r\n    'minCount',\r\n    'optional',\r\n    'regEx',\r\n    'skipRegExCheckForEmptyStrings'\r\n];\r\nclass SimpleSchema {\r\n    constructor(schema = {}, options = {}) {\r\n        var _a;\r\n        this._autoValues = [];\r\n        this._blackboxKeys = new Set();\r\n        this._cleanOptions = {};\r\n        this._constructorOptions = {};\r\n        this._docValidators = [];\r\n        this._firstLevelSchemaKeys = [];\r\n        this._rawDefinition = null;\r\n        this._schema = {};\r\n        this._schemaKeys = [];\r\n        // Named validation contexts\r\n        this._validationContexts = {};\r\n        this._validators = [];\r\n        /**\r\n         * @method SimpleSchema#pick\r\n         * @param {[fields]} The list of fields to pick to instantiate the subschema\r\n         * @returns {SimpleSchema} The subschema\r\n         */\r\n        this.pick = getPickOrOmit('pick');\r\n        /**\r\n         * @method SimpleSchema#omit\r\n         * @param {[fields]} The list of fields to omit to instantiate the subschema\r\n         * @returns {SimpleSchema} The subschema\r\n         */\r\n        this.omit = getPickOrOmit('omit');\r\n        // Stash the options object\r\n        this._constructorOptions = Object.assign(Object.assign({}, SimpleSchema._constructorOptionDefaults), options);\r\n        delete this._constructorOptions.clean; // stored separately below\r\n        // Schema-level defaults for cleaning\r\n        this._cleanOptions = Object.assign(Object.assign({}, SimpleSchema._constructorOptionDefaults.clean), ((_a = options.clean) !== null && _a !== void 0 ? _a : {}));\r\n        // Custom validators for this instance\r\n        this._docValidators = [];\r\n        // Clone, expanding shorthand, and store the schema object in this._schema\r\n        this.extend(schema);\r\n        // Clone raw definition and save if keepRawDefinition is active\r\n        if (this._constructorOptions.keepRawDefinition === true) {\r\n            this._rawDefinition = schema;\r\n        }\r\n        this.version = SimpleSchema.version;\r\n    }\r\n    /**\r\n    /* @returns The entire raw schema definition passed in the constructor\r\n    */\r\n    get rawDefinition() {\r\n        return this._rawDefinition;\r\n    }\r\n    forEachAncestorSimpleSchema(key, func) {\r\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\r\n        if (genericKey == null)\r\n            return;\r\n        (0, index_js_1.forEachKeyAncestor)(genericKey, (ancestor) => {\r\n            const def = this._schema[ancestor];\r\n            if (def == null)\r\n                return;\r\n            def.type.definitions.forEach((typeDef) => {\r\n                if (SimpleSchema.isSimpleSchema(typeDef.type)) {\r\n                    func(typeDef.type, ancestor, genericKey.slice(ancestor.length + 1));\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Returns whether the obj is a SimpleSchema object.\r\n     * @param [obj] An object to test\r\n     * @returns True if the given object appears to be a SimpleSchema instance\r\n     */\r\n    static isSimpleSchema(obj) {\r\n        if (obj == null)\r\n            return false;\r\n        return obj instanceof SimpleSchema || Object.prototype.hasOwnProperty.call(obj, '_schema');\r\n    }\r\n    /**\r\n     * @param key One specific or generic key for which to get the schema.\r\n     * @returns Returns a 2-tuple.\r\n     *\r\n     *   First item: The SimpleSchema instance that actually defines the given key.\r\n     *\r\n     *   For example, if you have several nested objects, each their own SimpleSchema\r\n     *   instance, and you pass in 'outerObj.innerObj.innermostObj.name' as the key, you'll\r\n     *   get back the SimpleSchema instance for `outerObj.innerObj.innermostObj` key.\r\n     *\r\n     *   But if you pass in 'outerObj.innerObj.innermostObj.name' as the key and that key is\r\n     *   defined in the main schema without use of subschemas, then you'll get back the main schema.\r\n     *\r\n     *   Second item: The part of the key that is in the found schema.\r\n     *\r\n     *   Always returns a tuple (array) but the values may be `null`.\r\n     */\r\n    nearestSimpleSchemaInstance(key) {\r\n        if (key == null)\r\n            return [null, null];\r\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\r\n        if (genericKey == null)\r\n            return [null, null];\r\n        if (this._schema[genericKey] !== undefined)\r\n            return [this, genericKey];\r\n        // If not defined in this schema, see if it's defined in a sub-schema\r\n        let innerKey;\r\n        let nearestSimpleSchemaInstance = null;\r\n        this.forEachAncestorSimpleSchema(key, (simpleSchema, ancestor, subSchemaKey) => {\r\n            if ((nearestSimpleSchemaInstance == null) &&\r\n                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n                simpleSchema._schema[subSchemaKey]) {\r\n                nearestSimpleSchemaInstance = simpleSchema;\r\n                innerKey = subSchemaKey;\r\n            }\r\n        });\r\n        return innerKey != null ? [nearestSimpleSchemaInstance, innerKey] : [null, null];\r\n    }\r\n    schema(key) {\r\n        if (key == null)\r\n            return this._schema;\r\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\r\n        let keySchema = genericKey == null ? null : this._schema[genericKey];\r\n        // If not defined in this schema, see if it's defined in a subschema\r\n        if (keySchema == null) {\r\n            let found = false;\r\n            this.forEachAncestorSimpleSchema(key, (simpleSchema, ancestor, subSchemaKey) => {\r\n                if (!found)\r\n                    keySchema = simpleSchema.schema(subSchemaKey);\r\n                if (keySchema != null)\r\n                    found = true;\r\n            });\r\n        }\r\n        return keySchema;\r\n    }\r\n    /**\r\n     * @returns {Object} The entire schema object with subschemas merged. This is the\r\n     * equivalent of what schema() returned in SimpleSchema < 2.0\r\n     *\r\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\r\n     * if you want the evaluated definition, where any properties that are functions\r\n     * have been run to produce a result.\r\n     */\r\n    mergedSchema() {\r\n        const mergedSchema = {};\r\n        this._schemaKeys.forEach((key) => {\r\n            const keySchema = this._schema[key];\r\n            mergedSchema[key] = keySchema;\r\n            keySchema.type.definitions.forEach((typeDef) => {\r\n                if (!SimpleSchema.isSimpleSchema(typeDef.type))\r\n                    return;\r\n                const childSchema = typeDef.type.mergedSchema();\r\n                Object.keys(childSchema).forEach((subKey) => {\r\n                    mergedSchema[`${key}.${subKey}`] = childSchema[subKey];\r\n                });\r\n            });\r\n        });\r\n        return mergedSchema;\r\n    }\r\n    /**\r\n     * Returns the evaluated definition for one key in the schema\r\n     *\r\n     * @param key Generic or specific schema key\r\n     * @param [propList] Array of schema properties you need; performance optimization\r\n     * @param [functionContext] The context to use when evaluating schema options that are functions\r\n     * @returns The schema definition for the requested key\r\n     */\r\n    getDefinition(key, propList, functionContext = {}) {\r\n        var _a;\r\n        const defs = this.schema(key);\r\n        if (defs == null)\r\n            return;\r\n        const getPropIterator = (obj, newObj) => {\r\n            return (prop) => {\r\n                if (Array.isArray(propList) && !propList.includes(prop))\r\n                    return;\r\n                const val = obj[prop];\r\n                // For any options that support specifying a function, evaluate the functions\r\n                if (propsThatCanBeFunction.includes(prop) &&\r\n                    typeof val === 'function') {\r\n                    newObj[prop] = val.call(Object.assign({ key }, functionContext));\r\n                    // Inflect label if undefined\r\n                    if (prop === 'label' && typeof newObj.label !== 'string') {\r\n                        newObj.label = inflectedLabel(key, this._constructorOptions.humanizeAutoLabels);\r\n                    }\r\n                }\r\n                else {\r\n                    newObj[prop] = val;\r\n                }\r\n            };\r\n        };\r\n        const result = {\r\n            type: []\r\n        };\r\n        Object.keys(defs).forEach(getPropIterator(defs, result));\r\n        // Resolve all the types and convert to a normal array to make it easier to use.\r\n        if (Array.isArray((_a = defs.type) === null || _a === void 0 ? void 0 : _a.definitions)) {\r\n            result.type = defs.type.definitions.map((typeDef) => {\r\n                const newTypeDef = {\r\n                    type: String // will be overwritten\r\n                };\r\n                Object.keys(typeDef).forEach(getPropIterator(typeDef, newTypeDef));\r\n                return newTypeDef;\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Returns a string identifying the best guess data type for a key. For keys\r\n     * that allow multiple types, the first type is used. This can be useful for\r\n     * building forms.\r\n     *\r\n     * @param key Generic or specific schema key\r\n     * @returns A type string. One of:\r\n     *  string, number, boolean, date, object, stringArray, numberArray, booleanArray,\r\n     *  dateArray, objectArray\r\n     */\r\n    getQuickTypeForKey(key) {\r\n        let type;\r\n        const fieldSchema = this.schema(key);\r\n        if (fieldSchema == null)\r\n            return;\r\n        const fieldType = (fieldSchema.type).singleType;\r\n        if (fieldType === String) {\r\n            type = 'string';\r\n        }\r\n        else if (fieldType === Number || fieldType === SimpleSchema.Integer) {\r\n            type = 'number';\r\n        }\r\n        else if (fieldType === Boolean) {\r\n            type = 'boolean';\r\n        }\r\n        else if (fieldType === Date) {\r\n            type = 'date';\r\n        }\r\n        else if (fieldType === Array) {\r\n            const arrayItemFieldSchema = this.schema(`${key}.$`);\r\n            if (arrayItemFieldSchema == null)\r\n                return;\r\n            const arrayItemFieldType = (arrayItemFieldSchema.type).singleType;\r\n            if (arrayItemFieldType === String) {\r\n                type = 'stringArray';\r\n            }\r\n            else if (arrayItemFieldType === Number ||\r\n                arrayItemFieldType === SimpleSchema.Integer) {\r\n                type = 'numberArray';\r\n            }\r\n            else if (arrayItemFieldType === Boolean) {\r\n                type = 'booleanArray';\r\n            }\r\n            else if (arrayItemFieldType === Date) {\r\n                type = 'dateArray';\r\n            }\r\n            else if (arrayItemFieldType === Object ||\r\n                SimpleSchema.isSimpleSchema(arrayItemFieldType)) {\r\n                type = 'objectArray';\r\n            }\r\n        }\r\n        else if (fieldType === Object) {\r\n            type = 'object';\r\n        }\r\n        return type;\r\n    }\r\n    /**\r\n     * Given a key that is an Object, returns a new SimpleSchema instance scoped to that object.\r\n     *\r\n     * @param key Generic or specific schema key\r\n     */\r\n    getObjectSchema(key) {\r\n        const newSchemaDef = {};\r\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\r\n        if (genericKey == null)\r\n            throw new Error(`Unable to make a generic key for ${key}`);\r\n        const searchString = `${genericKey}.`;\r\n        const mergedSchema = this.mergedSchema();\r\n        Object.keys(mergedSchema).forEach((k) => {\r\n            if (k.indexOf(searchString) === 0) {\r\n                newSchemaDef[k.slice(searchString.length)] = mergedSchema[k];\r\n            }\r\n        });\r\n        return this._copyWithSchema(newSchemaDef);\r\n    }\r\n    // Returns an array of all the autovalue functions, including those in subschemas all the\r\n    // way down the schema tree\r\n    autoValueFunctions() {\r\n        const result = [...this._autoValues];\r\n        this._schemaKeys.forEach((key) => {\r\n            this._schema[key].type.definitions.forEach((typeDef) => {\r\n                if (!SimpleSchema.isSimpleSchema(typeDef.type))\r\n                    return;\r\n                result.push(...typeDef.type\r\n                    .autoValueFunctions()\r\n                    .map(({ func, fieldName, closestSubschemaFieldName }) => {\r\n                    return {\r\n                        func,\r\n                        fieldName: `${key}.${fieldName}`,\r\n                        closestSubschemaFieldName: closestSubschemaFieldName.length > 0\r\n                            ? `${key}.${closestSubschemaFieldName}`\r\n                            : key\r\n                    };\r\n                }));\r\n            });\r\n        });\r\n        return result;\r\n    }\r\n    // Returns an array of all the blackbox keys, including those in subschemas\r\n    blackboxKeys() {\r\n        const blackboxKeys = new Set(this._blackboxKeys);\r\n        this._schemaKeys.forEach((key) => {\r\n            this._schema[key].type.definitions.forEach((typeDef) => {\r\n                if (!SimpleSchema.isSimpleSchema(typeDef.type))\r\n                    return;\r\n                typeDef.type.blackboxKeys().forEach((blackboxKey) => {\r\n                    blackboxKeys.add(`${key}.${blackboxKey}`);\r\n                });\r\n            });\r\n        });\r\n        return Array.from(blackboxKeys);\r\n    }\r\n    /**\r\n     * Check if the key is a nested dot-syntax key inside of a blackbox object\r\n     * @param key Key to check\r\n     * @returns True if key is in a black box object\r\n     */\r\n    keyIsInBlackBox(key) {\r\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\r\n        if (genericKey == null)\r\n            return false;\r\n        let isInBlackBox = false;\r\n        (0, index_js_1.forEachKeyAncestor)(genericKey, (ancestor, remainder) => {\r\n            if (this._blackboxKeys.has(ancestor)) {\r\n                isInBlackBox = true;\r\n            }\r\n            else {\r\n                const testKeySchema = this.schema(ancestor);\r\n                if (testKeySchema != null) {\r\n                    testKeySchema.type.definitions.forEach((typeDef) => {\r\n                        if (!SimpleSchema.isSimpleSchema(typeDef.type))\r\n                            return;\r\n                        if (typeDef.type.keyIsInBlackBox(remainder))\r\n                            isInBlackBox = true;\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        return isInBlackBox;\r\n    }\r\n    // Returns true if key is explicitly allowed by the schema or implied\r\n    // by other explicitly allowed keys.\r\n    // The key string should have $ in place of any numeric array positions.\r\n    allowsKey(key) {\r\n        // Loop through all keys in the schema\r\n        return this._schemaKeys.some((loopKey) => {\r\n            var _a;\r\n            // If the schema key is the test key, it's allowed.\r\n            if (loopKey === key)\r\n                return true;\r\n            const compare1 = key.slice(0, loopKey.length + 2);\r\n            const compare2 = compare1.slice(0, -1);\r\n            // Blackbox and subschema checks are needed only if key starts with\r\n            // loopKey + a dot\r\n            if (compare2 !== `${loopKey}.`)\r\n                return false;\r\n            // Black box handling\r\n            if (this._blackboxKeys.has(loopKey)) {\r\n                // If the test key is the black box key + \".$\", then the test\r\n                // key is NOT allowed because black box keys are by definition\r\n                // only for objects, and not for arrays.\r\n                return compare1 !== `${loopKey}.$`;\r\n            }\r\n            // Subschemas\r\n            let allowed = false;\r\n            const subKey = key.slice(loopKey.length + 1);\r\n            (_a = this.schema(loopKey)) === null || _a === void 0 ? void 0 : _a.type.definitions.forEach((typeDef) => {\r\n                if (!SimpleSchema.isSimpleSchema(typeDef.type))\r\n                    return;\r\n                if (typeDef.type.allowsKey(subKey))\r\n                    allowed = true;\r\n            });\r\n            return allowed;\r\n        });\r\n    }\r\n    /**\r\n     * Returns all the child keys for the object identified by the generic prefix,\r\n     * or all the top level keys if no prefix is supplied.\r\n     *\r\n     * @param [keyPrefix] The Object-type generic key for which to get child keys. Omit for\r\n     *   top-level Object-type keys\r\n     * @returns Array of child keys for the given object key\r\n     */\r\n    objectKeys(keyPrefix) {\r\n        var _a;\r\n        if (keyPrefix == null)\r\n            return this._firstLevelSchemaKeys;\r\n        const objectKeys = {};\r\n        const setObjectKeys = (curSchema, schemaParentKey) => {\r\n            Object.keys(curSchema).forEach((fieldName) => {\r\n                var _a;\r\n                const definition = curSchema[fieldName];\r\n                fieldName = schemaParentKey != null ? `${schemaParentKey}.${fieldName}` : fieldName;\r\n                if (fieldName.includes('.') && fieldName.slice(-2) !== '.$') {\r\n                    const parentKey = fieldName.slice(0, fieldName.lastIndexOf('.'));\r\n                    const parentKeyWithDot = `${parentKey}.`;\r\n                    objectKeys[parentKeyWithDot] = (_a = objectKeys[parentKeyWithDot]) !== null && _a !== void 0 ? _a : [];\r\n                    objectKeys[parentKeyWithDot].push(fieldName.slice(fieldName.lastIndexOf('.') + 1));\r\n                }\r\n                // If the current field is a nested SimpleSchema,\r\n                // iterate over the child fields and cache their properties as well\r\n                definition.type.definitions.forEach(({ type }) => {\r\n                    if (SimpleSchema.isSimpleSchema(type)) {\r\n                        setObjectKeys(type._schema, fieldName);\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        setObjectKeys(this._schema);\r\n        return (_a = objectKeys[`${keyPrefix}.`]) !== null && _a !== void 0 ? _a : [];\r\n    }\r\n    /**\r\n     * Copies this schema into a new instance with the same validators, messages,\r\n     * and options, but with different keys as defined in `schema` argument\r\n     *\r\n     * @param schema\r\n     * @returns The new SimpleSchema instance (chainable)\r\n     */\r\n    _copyWithSchema(schema) {\r\n        const cl = new SimpleSchema(schema, Object.assign({}, this._constructorOptions));\r\n        cl._cleanOptions = this._cleanOptions;\r\n        return cl;\r\n    }\r\n    /**\r\n     * Clones this schema into a new instance with the same schema keys, validators,\r\n     * and options.\r\n     *\r\n     * @returns The new SimpleSchema instance (chainable)\r\n     */\r\n    clone() {\r\n        return this._copyWithSchema(this._schema);\r\n    }\r\n    /**\r\n     * Extends (mutates) this schema with another schema, key by key.\r\n     *\r\n     * @param schema The schema or schema definition to extend onto this one\r\n     * @returns The SimpleSchema instance (chainable)\r\n     */\r\n    extend(schema = {}) {\r\n        if (Array.isArray(schema)) {\r\n            throw new Error('You may not pass an array of schemas to the SimpleSchema constructor or to extend()');\r\n        }\r\n        let schemaObj;\r\n        if (SimpleSchema.isSimpleSchema(schema)) {\r\n            schemaObj = schema._schema;\r\n            this._validators = this._validators.concat(schema._validators);\r\n            this._docValidators = this._docValidators.concat(schema._docValidators);\r\n            Object.assign(this._cleanOptions, schema._cleanOptions);\r\n            Object.assign(this._constructorOptions, schema._constructorOptions);\r\n        }\r\n        else {\r\n            schemaObj = (0, expandShorthand_js_1.default)(schema);\r\n        }\r\n        const schemaKeys = Object.keys(schemaObj);\r\n        const combinedKeys = new Set([...Object.keys(this._schema), ...schemaKeys]);\r\n        // Update all of the information cached on the instance\r\n        schemaKeys.forEach((fieldName) => {\r\n            const definition = standardizeDefinition(schemaObj[fieldName]);\r\n            // Merge/extend with any existing definition\r\n            if (this._schema[fieldName] != null) {\r\n                if (!Object.prototype.hasOwnProperty.call(this._schema, fieldName)) {\r\n                    // fieldName is actually a method from Object itself!\r\n                    throw new Error(`${fieldName} key is actually the name of a method on Object, please rename it`);\r\n                }\r\n                const { type } = definition, definitionWithoutType = __rest(definition, [\"type\"]); // eslint-disable-line no-unused-vars\r\n                this._schema[fieldName] = Object.assign(Object.assign({}, this._schema[fieldName]), definitionWithoutType);\r\n                if (definition.type != null) {\r\n                    this._schema[fieldName].type.extend(definition.type);\r\n                }\r\n            }\r\n            else {\r\n                this._schema[fieldName] = definition;\r\n            }\r\n            checkAndScrubDefinition(fieldName, this._schema[fieldName], this._constructorOptions, combinedKeys);\r\n        });\r\n        checkSchemaOverlap(this._schema);\r\n        // Set/Reset all of these\r\n        this._schemaKeys = Object.keys(this._schema);\r\n        this._autoValues = [];\r\n        this._blackboxKeys = new Set();\r\n        this._firstLevelSchemaKeys = [];\r\n        // Update all of the information cached on the instance\r\n        this._schemaKeys.forEach((fieldName) => {\r\n            // Make sure parent has a definition in the schema. No implied objects!\r\n            if (fieldName.includes('.')) {\r\n                const parentFieldName = fieldName.slice(0, fieldName.lastIndexOf('.'));\r\n                if (!Object.prototype.hasOwnProperty.call(this._schema, parentFieldName)) {\r\n                    throw new Error(`\"${fieldName}\" is in the schema but \"${parentFieldName}\" is not`);\r\n                }\r\n            }\r\n            const definition = this._schema[fieldName];\r\n            // Keep list of all top level keys\r\n            if (!fieldName.includes('.')) {\r\n                this._firstLevelSchemaKeys.push(fieldName);\r\n            }\r\n            // Keep list of all blackbox keys for passing to MongoObject constructor\r\n            // XXX For now if any oneOf type is blackbox, then the whole field is.\r\n            /* eslint-disable no-restricted-syntax */\r\n            for (const oneOfDef of definition.type.definitions) {\r\n                // XXX If the type is SS.Any, also consider it a blackbox\r\n                if (oneOfDef.blackbox === true || oneOfDef.type === SimpleSchema.Any) {\r\n                    this._blackboxKeys.add(fieldName);\r\n                    break;\r\n                }\r\n            }\r\n            /* eslint-enable no-restricted-syntax */\r\n            // Keep list of autoValue functions\r\n            if (typeof definition.autoValue === 'function') {\r\n                this._autoValues.push({\r\n                    closestSubschemaFieldName: '',\r\n                    fieldName,\r\n                    func: definition.autoValue\r\n                });\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n    getAllowedValuesForKey(key) {\r\n        // For array fields, `allowedValues` is on the array item definition\r\n        if (this.allowsKey(`${key}.$`)) {\r\n            key = `${key}.$`;\r\n        }\r\n        const allowedValues = this.get(key, 'allowedValues');\r\n        if (Array.isArray(allowedValues) || allowedValues instanceof Set) {\r\n            return [...allowedValues];\r\n        }\r\n        return null;\r\n    }\r\n    newContext() {\r\n        return new ValidationContext_js_1.default(this);\r\n    }\r\n    namedContext(name) {\r\n        if (typeof name !== 'string')\r\n            name = 'default';\r\n        if (this._validationContexts[name] == null) {\r\n            this._validationContexts[name] = new ValidationContext_js_1.default(this, name);\r\n        }\r\n        return this._validationContexts[name];\r\n    }\r\n    addValidator(func) {\r\n        this._validators.push(func);\r\n    }\r\n    addDocValidator(func) {\r\n        this._docValidators.push(func);\r\n    }\r\n    /**\r\n     * @param obj Object or array of objects to validate.\r\n     * @param options Same options object that ValidationContext#validate takes\r\n     *\r\n     * Throws an Error with name `ClientError` and `details` property containing the errors.\r\n     */\r\n    validate(obj, options = {}) {\r\n        // obj can be an array, in which case we validate each object in it and\r\n        // throw as soon as one has an error\r\n        const objects = Array.isArray(obj) ? obj : [obj];\r\n        objects.forEach((oneObj) => {\r\n            const validationContext = this.newContext();\r\n            const isValid = validationContext.validate(oneObj, options);\r\n            if (isValid)\r\n                return;\r\n            const errors = validationContext.validationErrors();\r\n            // In order for the message at the top of the stack trace to be useful,\r\n            // we set it to the first validation error message.\r\n            const message = this.messageForError(errors[0]);\r\n            const error = new errors_js_1.ClientError(message, 'validation-error');\r\n            // Add meaningful error messages for each validation error.\r\n            // Useful for display messages when using 'mdg:validated-method'.\r\n            error.details = errors.map((errorDetail) => (Object.assign(Object.assign({}, errorDetail), { message: this.messageForError(errorDetail) })));\r\n            // The primary use for the validationErrorTransform is to convert the\r\n            // vanilla Error into a Meteor.Error until DDP is able to pass\r\n            // vanilla errors back to the client.\r\n            if (typeof SimpleSchema.validationErrorTransform === 'function') {\r\n                throw SimpleSchema.validationErrorTransform(error);\r\n            }\r\n            else {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @param obj Object to validate.\r\n     * @param options Same options object that ValidationContext#validate takes\r\n     *\r\n     * Returns a Promise that resolves with the errors\r\n     */\r\n    validateAndReturnErrorsPromise(obj, options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const validationContext = this.newContext();\r\n            const isValid = validationContext.validate(obj, options);\r\n            if (isValid)\r\n                return [];\r\n            // Add the `message` prop\r\n            return validationContext.validationErrors().map((errorDetail) => {\r\n                return Object.assign(Object.assign({}, errorDetail), { message: this.messageForError(errorDetail) });\r\n            });\r\n        });\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\r\n    validator(options = {}) {\r\n        return (obj) => {\r\n            const optionsClone = Object.assign({}, options);\r\n            if (options.clean === true) {\r\n                // Do this here and pass into both functions for better performance\r\n                optionsClone.mongoObject = new mongo_object_1.default(obj, this.blackboxKeys());\r\n                this.clean(obj, optionsClone);\r\n            }\r\n            if (options.returnErrorsPromise === true) {\r\n                return this.validateAndReturnErrorsPromise(obj, optionsClone);\r\n            }\r\n            return this.validate(obj, optionsClone);\r\n        };\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\r\n    getFormValidator(options = {}) {\r\n        return this.validator(Object.assign(Object.assign({}, options), { returnErrorsPromise: true }));\r\n    }\r\n    clean(doc, options = {}) {\r\n        return (0, clean_js_1.default)(this, doc, options);\r\n    }\r\n    /**\r\n     * Change schema labels on the fly. Useful when the user changes the language.\r\n     *\r\n     * @param labels A dictionary of all the new label values, by schema key.\r\n     */\r\n    labels(labels) {\r\n        for (const [key, label] of Object.entries(labels)) {\r\n            if (typeof label !== 'string' && typeof label !== 'function')\r\n                continue;\r\n            // Support setting labels that were actually originally defined in a sub-schema\r\n            const [schemaInstance, innerKey] = this.nearestSimpleSchemaInstance(key);\r\n            if (schemaInstance == null || innerKey == null)\r\n                continue;\r\n            schemaInstance._schema[innerKey].label = label;\r\n        }\r\n    }\r\n    label(key) {\r\n        // Get all labels\r\n        if (key === null || key === undefined) {\r\n            const result = {};\r\n            this._schemaKeys.forEach((schemaKey) => {\r\n                result[schemaKey] = this.label(schemaKey);\r\n            });\r\n            return result;\r\n        }\r\n        // Get label for one field\r\n        const label = this.get(key, 'label');\r\n        return label !== null && label !== void 0 ? label : null;\r\n    }\r\n    /**\r\n     * Gets a field's property\r\n     *\r\n     * @param key The schema key, specific or generic.\r\n     * @param prop Name of the property to get for that schema key\r\n     * @param functionContext The `this` context to use if prop is a function\r\n     * @returns The property value\r\n     */\r\n    get(key, prop, functionContext) {\r\n        const def = this.getDefinition(key, ['type', prop], functionContext);\r\n        if (def == null)\r\n            return undefined;\r\n        if (exports.schemaDefinitionOptions.includes(prop)) {\r\n            return def[prop];\r\n        }\r\n        const oneType = def.type[0];\r\n        if (oneType === SimpleSchema.Any)\r\n            return undefined;\r\n        return oneType === null || oneType === void 0 ? void 0 : oneType[prop];\r\n    }\r\n    // shorthand for getting defaultValue\r\n    defaultValue(key) {\r\n        return this.get(key, 'defaultValue');\r\n    }\r\n    // Returns a string message for the given error type and key.\r\n    // Defers to a user-provided getErrorMessage function, which\r\n    // can do custom messages and translations, or falls back to\r\n    // built-in English defaults.\r\n    messageForError(errorInfo) {\r\n        var _a, _b;\r\n        const { name } = errorInfo;\r\n        const label = this.label(name);\r\n        let message;\r\n        if (this._constructorOptions.getErrorMessage !== undefined) {\r\n            message = this._constructorOptions.getErrorMessage(errorInfo, label);\r\n            if (message !== undefined)\r\n                return message;\r\n        }\r\n        if (((_a = globalThis.simpleSchemaGlobalConfig) === null || _a === void 0 ? void 0 : _a.getErrorMessage) !== undefined) {\r\n            message = (_b = globalThis.simpleSchemaGlobalConfig) === null || _b === void 0 ? void 0 : _b.getErrorMessage(errorInfo, label);\r\n            if (message !== undefined)\r\n                return message;\r\n        }\r\n        return (0, defaultMessages_js_1.getDefaultErrorMessage)(errorInfo, label);\r\n    }\r\n    /**\r\n     * If you need to allow properties other than those listed above, call this from your app or package\r\n     * @param options Additional allowed options\r\n     */\r\n    static extendOptions(options) {\r\n        exports.schemaDefinitionOptions.push(...options);\r\n    }\r\n    static defineValidationErrorTransform(transform) {\r\n        if (typeof transform !== 'function') {\r\n            throw new Error('SimpleSchema.defineValidationErrorTransform must be passed a function that accepts an Error and returns an Error');\r\n        }\r\n        SimpleSchema.validationErrorTransform = transform;\r\n    }\r\n    static validate(obj, schema, options) {\r\n        // Allow passing just the schema object\r\n        if (!SimpleSchema.isSimpleSchema(schema)) {\r\n            schema = new SimpleSchema(schema);\r\n        }\r\n        return schema.validate(obj, options);\r\n    }\r\n    static oneOf(...definitions) {\r\n        return new SimpleSchemaGroup_js_1.default(...definitions);\r\n    }\r\n    static addValidator(func) {\r\n        SimpleSchema._validators.push(func);\r\n    }\r\n    static addDocValidator(func) {\r\n        SimpleSchema._docValidators.push(func);\r\n    }\r\n    /**\r\n     * @summary Get/set default values for SimpleSchema constructor options\r\n     */\r\n    static constructorOptionDefaults(options) {\r\n        var _a;\r\n        if (options == null)\r\n            return SimpleSchema._constructorOptionDefaults;\r\n        SimpleSchema._constructorOptionDefaults = Object.assign(Object.assign(Object.assign({}, SimpleSchema._constructorOptionDefaults), options), { clean: Object.assign(Object.assign({}, SimpleSchema._constructorOptionDefaults.clean), ((_a = options.clean) !== null && _a !== void 0 ? _a : {})) });\r\n    }\r\n}\r\nexports.SimpleSchema = SimpleSchema;\r\nSimpleSchema.version = 2;\r\n// Global constructor options\r\nSimpleSchema._constructorOptionDefaults = {\r\n    clean: {\r\n        autoConvert: true,\r\n        extendAutoValueContext: {},\r\n        filter: true,\r\n        getAutoValues: true,\r\n        removeEmptyStrings: true,\r\n        removeNullsFromArrays: false,\r\n        trimStrings: true\r\n    },\r\n    humanizeAutoLabels: true,\r\n    requiredByDefault: true\r\n};\r\nSimpleSchema._docValidators = [];\r\nSimpleSchema._validators = [];\r\nSimpleSchema.Any = '___Any___';\r\nSimpleSchema.ErrorTypes = {\r\n    REQUIRED: 'required',\r\n    MIN_STRING: 'minString',\r\n    MAX_STRING: 'maxString',\r\n    MIN_NUMBER: 'minNumber',\r\n    MAX_NUMBER: 'maxNumber',\r\n    MIN_NUMBER_EXCLUSIVE: 'minNumberExclusive',\r\n    MAX_NUMBER_EXCLUSIVE: 'maxNumberExclusive',\r\n    MIN_DATE: 'minDate',\r\n    MAX_DATE: 'maxDate',\r\n    BAD_DATE: 'badDate',\r\n    MIN_COUNT: 'minCount',\r\n    MAX_COUNT: 'maxCount',\r\n    MUST_BE_INTEGER: 'noDecimal',\r\n    VALUE_NOT_ALLOWED: 'notAllowed',\r\n    EXPECTED_TYPE: 'expectedType',\r\n    FAILED_REGULAR_EXPRESSION: 'regEx',\r\n    KEY_NOT_IN_SCHEMA: 'keyNotInSchema'\r\n};\r\nSimpleSchema.Integer = 'SimpleSchema.Integer';\r\nSimpleSchema.ValidationContext = ValidationContext_js_1.default;\r\n/*\r\n * PRIVATE\r\n */\r\n// Throws an error if any fields are `type` SimpleSchema but then also\r\n// have subfields defined outside of that.\r\nfunction checkSchemaOverlap(schema) {\r\n    Object.keys(schema).forEach((key) => {\r\n        const val = schema[key];\r\n        if (val.type == null)\r\n            throw new Error(`${key} key is missing \"type\"`);\r\n        val.type.definitions.forEach((def) => {\r\n            if (!SimpleSchema.isSimpleSchema(def.type))\r\n                return;\r\n            // @ts-expect-error\r\n            Object.keys(def.type._schema).forEach((subKey) => {\r\n                const newKey = `${key}.${subKey}`;\r\n                if (Object.prototype.hasOwnProperty.call(schema, newKey)) {\r\n                    throw new Error(`The type for \"${key}\" is set to a SimpleSchema instance that defines \"${key}.${subKey}\", but the parent SimpleSchema instance also tries to define \"${key}.${subKey}\"`);\r\n                }\r\n            });\r\n        });\r\n    });\r\n}\r\n/**\r\n * @param fieldName The full generic schema key\r\n * @param shouldHumanize Humanize it\r\n * @returns A label based on the key\r\n */\r\nfunction inflectedLabel(fieldName, shouldHumanize = false) {\r\n    const pieces = fieldName.split('.');\r\n    let label;\r\n    do {\r\n        label = pieces.pop();\r\n    } while (label === '$' && (pieces.length > 0));\r\n    return (label != null && shouldHumanize) ? (0, index_js_1.humanize)(label) : (label !== null && label !== void 0 ? label : '');\r\n}\r\nfunction getDefaultAutoValueFunction(defaultValue) {\r\n    return function defaultAutoValueFunction() {\r\n        if (this.isSet)\r\n            return;\r\n        if (this.operator === null)\r\n            return defaultValue;\r\n        // Handle the case when pulling an object from an array the object contains a field\r\n        // which has a defaultValue. We don't want the default value to be returned in this case\r\n        if (this.operator === '$pull')\r\n            return;\r\n        // Handle the case where we are $pushing an object into an array of objects and we\r\n        // want any fields missing from that object to be added if they have default values\r\n        if (this.operator === '$push')\r\n            return defaultValue;\r\n        // If parent is set, we should update this position instead of $setOnInsert\r\n        if (this.parentField().isSet)\r\n            return defaultValue;\r\n        // Make sure the default value is added on upsert insert\r\n        if (this.isUpsert)\r\n            return { $setOnInsert: defaultValue };\r\n    };\r\n}\r\n// Mutates def into standardized object with SimpleSchemaGroup type\r\nfunction standardizeDefinition(def) {\r\n    const standardizedDef = {};\r\n    for (const prop of Object.keys(def)) {\r\n        if (!oneOfProps.includes(prop)) {\r\n            // @ts-expect-error Copying properties\r\n            standardizedDef[prop] = def[prop];\r\n        }\r\n    }\r\n    // Internally, all definition types are stored as groups for simplicity of access.\r\n    // If we are extending, there may not actually be def.type, but it's okay because\r\n    // it will be added later when the two SimpleSchemaGroups are merged.\r\n    if (def.type instanceof SimpleSchemaGroup_js_1.default) {\r\n        standardizedDef.type = def.type.clone();\r\n    }\r\n    else {\r\n        const groupProps = {};\r\n        for (const prop of Object.keys(def)) {\r\n            if (oneOfProps.includes(prop)) {\r\n                // @ts-expect-error Copying properties\r\n                groupProps[prop] = def[prop];\r\n            }\r\n        }\r\n        standardizedDef.type = new SimpleSchemaGroup_js_1.default(groupProps);\r\n    }\r\n    return standardizedDef;\r\n}\r\n/**\r\n * @summary Checks and mutates definition. Clone it first.\r\n *   Throws errors if any problems are found.\r\n * @param fieldName Name of field / key\r\n * @param definition Field definition\r\n * @param options Options\r\n * @param allKeys Set of all field names / keys in entire schema\r\n */\r\nfunction checkAndScrubDefinition(fieldName, definition, options, allKeys) {\r\n    var _a;\r\n    if (definition.type == null)\r\n        throw new Error(`${fieldName} key is missing \"type\"`);\r\n    // Validate the field definition\r\n    Object.keys(definition).forEach((key) => {\r\n        if (!exports.schemaDefinitionOptions.includes(key)) {\r\n            throw new Error(`Invalid definition for ${fieldName} field: \"${key}\" is not a supported property`);\r\n        }\r\n    });\r\n    // Make sure the `type`s are OK\r\n    let couldBeArray = false;\r\n    definition.type.definitions.forEach(({ type }) => {\r\n        if (type == null) {\r\n            throw new Error(`Invalid definition for ${fieldName} field: \"type\" option is required`);\r\n        }\r\n        if (Array.isArray(type)) {\r\n            throw new Error(`Invalid definition for ${fieldName} field: \"type\" may not be an array. Change it to Array.`);\r\n        }\r\n        if (type.constructor === Object && (0, index_js_1.isEmptyObject)(type)) {\r\n            throw new Error(`Invalid definition for ${fieldName} field: \"type\" may not be an object. Change it to Object`);\r\n        }\r\n        if (type === Array)\r\n            couldBeArray = true;\r\n        if (SimpleSchema.isSimpleSchema(type)) {\r\n            // @ts-expect-error\r\n            Object.keys(type._schema).forEach((subKey) => {\r\n                const newKey = `${fieldName}.${subKey}`;\r\n                if (allKeys.has(newKey)) {\r\n                    throw new Error(`The type for \"${fieldName}\" is set to a SimpleSchema instance that defines \"${newKey}\", but the parent SimpleSchema instance also tries to define \"${newKey}\"`);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    // If at least one of the possible types is Array, then make sure we have a\r\n    // definition for the array items, too.\r\n    if (couldBeArray && !allKeys.has(`${fieldName}.$`)) {\r\n        throw new Error(`\"${fieldName}\" is Array type but the schema does not include a \"${fieldName}.$\" definition for the array items\"`);\r\n    }\r\n    // defaultValue -> autoValue\r\n    // We support defaultValue shortcut by converting it immediately into an\r\n    // autoValue.\r\n    if ('defaultValue' in definition) {\r\n        if ('autoValue' in definition && ((_a = definition.autoValue) === null || _a === void 0 ? void 0 : _a.isDefault) !== true) {\r\n            console.warn(`SimpleSchema: Found both autoValue and defaultValue options for \"${fieldName}\". Ignoring defaultValue.`);\r\n        }\r\n        else {\r\n            if (fieldName.endsWith('.$')) {\r\n                throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.');\r\n            }\r\n            definition.autoValue = getDefaultAutoValueFunction(definition.defaultValue);\r\n            definition.autoValue.isDefault = true;\r\n        }\r\n    }\r\n    // REQUIREDNESS\r\n    if (fieldName.endsWith('.$')) {\r\n        definition.optional = true;\r\n    }\r\n    else if (!Object.prototype.hasOwnProperty.call(definition, 'optional')) {\r\n        if (Object.prototype.hasOwnProperty.call(definition, 'required')) {\r\n            if (typeof definition.required === 'function') {\r\n                // Save a reference to the `required` fn because\r\n                // we are going to delete it from `definition` below\r\n                const requiredFn = definition.required;\r\n                definition.optional = function optional(...args) {\r\n                    return !requiredFn.apply(this, args);\r\n                };\r\n            }\r\n            else {\r\n                definition.optional = definition.required !== true;\r\n            }\r\n        }\r\n        else {\r\n            definition.optional = options.requiredByDefault === false;\r\n        }\r\n    }\r\n    delete definition.required;\r\n    // LABELS\r\n    if (!Object.prototype.hasOwnProperty.call(definition, 'label')) {\r\n        if (options.defaultLabel != null) {\r\n            definition.label = options.defaultLabel;\r\n        }\r\n        else if (SimpleSchema.defaultLabel != null) {\r\n            definition.label = SimpleSchema.defaultLabel;\r\n        }\r\n        else {\r\n            definition.label = inflectedLabel(fieldName, options.humanizeAutoLabels);\r\n        }\r\n    }\r\n}\r\nfunction getPickOrOmit(type) {\r\n    return function pickOrOmit(...args) {\r\n        // If they are picking/omitting an object or array field, we need to also include everything under it\r\n        const newSchema = {};\r\n        // @ts-expect-error\r\n        this._schemaKeys.forEach((key) => {\r\n            // Pick/omit it if it IS in the array of keys they want OR if it\r\n            // STARTS WITH something that is in the array plus a period\r\n            const includeIt = args.some((wantedField) => key === wantedField || key.indexOf(`${wantedField}.`) === 0);\r\n            if ((includeIt && type === 'pick') || (!includeIt && type === 'omit')) {\r\n                // @ts-expect-error\r\n                newSchema[key] = this._schema[key];\r\n            }\r\n        });\r\n        return this._copyWithSchema(newSchema);\r\n    };\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"defaultMessages.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/defaultMessages.js                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getDefaultErrorMessage = void 0;\r\nconst defaultMessages = {\r\n    badDate: (_, label) => `${String(label)} is not a valid date`,\r\n    expectedType: ({ dataType }, label) => `${String(label)} must be of type ${String(dataType)}`,\r\n    keyNotInSchema: ({ name }) => `${name} is not allowed by the schema`,\r\n    maxCount: ({ maxCount }) => `You cannot specify more than ${String(maxCount)} values`,\r\n    maxDate: ({ max }, label) => `${String(label)} cannot be after ${String(max)}`,\r\n    maxNumber: ({ max }, label) => `${String(label)} cannot exceed ${String(max)}`,\r\n    maxNumberExclusive: ({ max }, label) => `${String(label)} must be less than ${String(max)}`,\r\n    maxString: ({ max }, label) => `${String(label)} cannot exceed ${String(max)} characters`,\r\n    minCount: ({ minCount }) => `You must specify at least ${String(minCount)} values`,\r\n    minDate: ({ min }, label) => `${String(label)} must be on or after ${String(min)}`,\r\n    minNumber: ({ min }, label) => `${String(label)} must be at least ${String(min)}`,\r\n    minNumberExclusive: ({ min }, label) => `${String(label)} must be greater than ${String(min)}`,\r\n    minString: ({ min }, label) => `${String(label)} must be at least ${String(min)} characters`,\r\n    noDecimal: (_, label) => `${String(label)} must be an integer`,\r\n    notAllowed: ({ value }) => `${String(value)} is not an allowed value`,\r\n    regEx: (_, label) => `${String(label)} failed regular expression validation`,\r\n    required: (_, label) => `${String(label)} is required`\r\n};\r\nfunction getDefaultErrorMessage(errorInfo, label) {\r\n    const msgFn = defaultMessages[errorInfo.type];\r\n    return typeof msgFn === 'function' ? msgFn(errorInfo, label) : `${errorInfo.type} ${errorInfo.name}`;\r\n}\r\nexports.getDefaultErrorMessage = getDefaultErrorMessage;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"errors.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/errors.js                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ClientError = void 0;\r\nclass ClientError extends Error {\r\n    constructor(message, error) {\r\n        super(message);\r\n        this.errorType = 'ClientError';\r\n        this.name = 'ClientError';\r\n        this.error = error;\r\n    }\r\n}\r\nexports.ClientError = ClientError;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"expandShorthand.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/expandShorthand.js                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\r\n/**\r\n * Clones a schema object, expanding shorthand as it does it.\r\n */\r\nfunction expandShorthand(schema) {\r\n    const schemaClone = {};\r\n    Object.keys(schema).forEach((key) => {\r\n        const definition = schema[key];\r\n        // CASE 1: Not shorthand. Just clone\r\n        if (mongo_object_1.default.isBasicObject(definition)) {\r\n            // @ts-expect-error We're pretty sure it's correct\r\n            schemaClone[key] = Object.assign({}, definition);\r\n            return;\r\n        }\r\n        // CASE 2: The definition is an array of some type\r\n        if (Array.isArray(definition)) {\r\n            if (Array.isArray(definition[0])) {\r\n                throw new Error(`Array shorthand may only be used to one level of depth (${key})`);\r\n            }\r\n            const type = definition[0];\r\n            schemaClone[key] = { type: Array };\r\n            // Also add the item key definition\r\n            const itemKey = `${key}.$`;\r\n            if (schema[itemKey] !== undefined) {\r\n                throw new Error(`Array shorthand used for ${key} field but ${key}.$ key is already in the schema`);\r\n            }\r\n            if (type instanceof RegExp) {\r\n                schemaClone[itemKey] = { type: String, regEx: type };\r\n            }\r\n            else {\r\n                schemaClone[itemKey] = { type };\r\n            }\r\n            return;\r\n        }\r\n        // CASE 3: The definition is a regular expression\r\n        if (definition instanceof RegExp) {\r\n            schemaClone[key] = {\r\n                type: String,\r\n                regEx: definition\r\n            };\r\n            return;\r\n        }\r\n        // CASE 4: The definition is something, a type\r\n        schemaClone[key] = { type: definition };\r\n    });\r\n    return schemaClone;\r\n}\r\nexports.default = expandShorthand;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"SimpleSchemaGroup.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/SimpleSchemaGroup.js                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\r\nclass SimpleSchemaGroup {\r\n    constructor(...definitions) {\r\n        this.definitions = [];\r\n        this.definitions = definitions.map((definition) => {\r\n            if (mongo_object_1.default.isBasicObject(definition)) {\r\n                return Object.assign({}, definition);\r\n            }\r\n            if (definition instanceof RegExp) {\r\n                return {\r\n                    type: String,\r\n                    regEx: definition\r\n                };\r\n            }\r\n            return { type: definition };\r\n        });\r\n    }\r\n    get singleType() {\r\n        return this.definitions[0].type;\r\n    }\r\n    clone() {\r\n        return new SimpleSchemaGroup(...this.definitions);\r\n    }\r\n    extend(otherGroup) {\r\n        // We extend based on index being the same. No better way I can think of at the moment.\r\n        this.definitions = this.definitions.map((def, index) => {\r\n            const otherDef = otherGroup.definitions[index];\r\n            if (otherDef === undefined)\r\n                return def;\r\n            return Object.assign(Object.assign({}, def), otherDef);\r\n        });\r\n    }\r\n}\r\nexports.default = SimpleSchemaGroup;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"utility\":{\"index.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/utility/index.js                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.humanize = exports.looksLikeModifier = exports.isObjectWeShouldTraverse = exports.isEmptyObject = exports.getParentOfKey = exports.getLastPartOfKey = exports.getKeysWithValueInObj = exports.forEachKeyAncestor = exports.dateToDateString = exports.appendAffectedKey = void 0;\r\nfunction appendAffectedKey(affectedKey, key) {\r\n    if (key === '$each')\r\n        return affectedKey;\r\n    return affectedKey == null ? key : `${affectedKey}.${key}`;\r\n}\r\nexports.appendAffectedKey = appendAffectedKey;\r\n/**\r\n * Given a Date instance, returns a date string of the format YYYY-MM-DD\r\n */\r\nfunction dateToDateString(date) {\r\n    let month = date.getUTCMonth() + 1;\r\n    if (month < 10)\r\n        month = `0${month}`;\r\n    let day = date.getUTCDate();\r\n    if (day < 10)\r\n        day = `0${day}`;\r\n    return `${date.getUTCFullYear()}-${month}-${day}`;\r\n}\r\nexports.dateToDateString = dateToDateString;\r\n/**\r\n * Run loopFunc for each ancestor key in a dot-delimited key. For example,\r\n * if key is \"a.b.c\", loopFunc will be called first with ('a.b', 'c') and then with ('a', 'b.c')\r\n */\r\nfunction forEachKeyAncestor(key, loopFunc) {\r\n    let lastDot;\r\n    // Iterate the dot-syntax hierarchy\r\n    let ancestor = key;\r\n    do {\r\n        lastDot = ancestor.lastIndexOf('.');\r\n        if (lastDot !== -1) {\r\n            ancestor = ancestor.slice(0, lastDot);\r\n            const remainder = key.slice(ancestor.length + 1);\r\n            loopFunc(ancestor, remainder); // Remove last path component\r\n        }\r\n    } while (lastDot !== -1);\r\n}\r\nexports.forEachKeyAncestor = forEachKeyAncestor;\r\n/**\r\n * Returns an array of keys that are in obj, have a value\r\n * other than null or undefined, and start with matchKey\r\n * plus a dot.\r\n */\r\nfunction getKeysWithValueInObj(obj, matchKey) {\r\n    const keysWithValue = [];\r\n    const keyAdjust = (key) => key.slice(0, matchKey.length + 1);\r\n    const matchKeyPlusDot = `${matchKey}.`;\r\n    Object.keys(obj !== null && obj !== void 0 ? obj : {}).forEach((key) => {\r\n        const val = obj[key];\r\n        if (val === undefined || val === null)\r\n            return;\r\n        if (keyAdjust(key) === matchKeyPlusDot) {\r\n            keysWithValue.push(key);\r\n        }\r\n    });\r\n    return keysWithValue;\r\n}\r\nexports.getKeysWithValueInObj = getKeysWithValueInObj;\r\n/**\r\n * Returns the ending of key, after stripping out the beginning\r\n * ancestorKey and any array placeholders\r\n *\r\n * getLastPartOfKey('a.b.c', 'a') returns 'b.c'\r\n * getLastPartOfKey('a.b.$.c', 'a.b') returns 'c'\r\n */\r\nfunction getLastPartOfKey(key, ancestorKey) {\r\n    let lastPart = '';\r\n    const startString = `${ancestorKey}.`;\r\n    if (key.indexOf(startString) === 0) {\r\n        lastPart = key.replace(startString, '');\r\n        if (lastPart.startsWith('$.'))\r\n            lastPart = lastPart.slice(2);\r\n    }\r\n    return lastPart;\r\n}\r\nexports.getLastPartOfKey = getLastPartOfKey;\r\n/**\r\n * Returns the parent of a key. For example, returns 'a.b' when passed 'a.b.c'.\r\n * If no parent, returns an empty string. If withEndDot is true, the return\r\n * value will have a dot appended when it isn't an empty string.\r\n */\r\nfunction getParentOfKey(key, withEndDot = false) {\r\n    const lastDot = key.lastIndexOf('.');\r\n    return lastDot === -1 ? '' : key.slice(0, lastDot + Number(withEndDot));\r\n}\r\nexports.getParentOfKey = getParentOfKey;\r\n/**\r\n * @summary Determines whether the object has any \"own\" properties\r\n * @param {Object} obj Object to test\r\n * @return {Boolean} True if it has no \"own\" properties\r\n */\r\nfunction isEmptyObject(obj) {\r\n    /* eslint-disable no-restricted-syntax */\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    /* eslint-enable no-restricted-syntax */\r\n    return true;\r\n}\r\nexports.isEmptyObject = isEmptyObject;\r\nfunction isObjectWeShouldTraverse(val) {\r\n    // Some of these types don't exist in old browsers so we'll catch and return false in those cases\r\n    try {\r\n        if (val !== Object(val))\r\n            return false;\r\n        // There are some object types that we know we shouldn't traverse because\r\n        // they will often result in overflows and it makes no sense to validate them.\r\n        if (val instanceof Date)\r\n            return false;\r\n        if (val instanceof Int8Array)\r\n            return false;\r\n        if (val instanceof Uint8Array)\r\n            return false;\r\n        if (val instanceof Uint8ClampedArray)\r\n            return false;\r\n        if (val instanceof Int16Array)\r\n            return false;\r\n        if (val instanceof Uint16Array)\r\n            return false;\r\n        if (val instanceof Int32Array)\r\n            return false;\r\n        if (val instanceof Uint32Array)\r\n            return false;\r\n        if (val instanceof Float32Array)\r\n            return false;\r\n        if (val instanceof Float64Array)\r\n            return false;\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nexports.isObjectWeShouldTraverse = isObjectWeShouldTraverse;\r\n/**\r\n * Returns true if any of the keys of obj start with a $\r\n */\r\nfunction looksLikeModifier(obj) {\r\n    return Object.keys(obj !== null && obj !== void 0 ? obj : {}).some((key) => key.substring(0, 1) === '$');\r\n}\r\nexports.looksLikeModifier = looksLikeModifier;\r\nvar humanize_js_1 = require(\"./humanize.js\");\r\nObject.defineProperty(exports, \"humanize\", { enumerable: true, get: function () { return humanize_js_1.humanize; } });\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"humanize.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/utility/humanize.js                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\n/*\r\n  Code source:\r\n    https://github.com/jxson/string-humanize\r\n    https://github.com/jxson/string-capitalize\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.humanize = exports.extname = exports.underscore = exports.capitalize = void 0;\r\nfunction capitalize(text) {\r\n    text = text !== null && text !== void 0 ? text : '';\r\n    text = text.trim();\r\n    if (text[0] !== undefined) {\r\n        text = text[0].toUpperCase() + text.substr(1).toLowerCase();\r\n    }\r\n    // Do \"ID\" instead of \"id\" or \"Id\"\r\n    text = text.replace(/\\bid\\b/g, 'ID');\r\n    text = text.replace(/\\bId\\b/g, 'ID');\r\n    return text;\r\n}\r\nexports.capitalize = capitalize;\r\nfunction underscore(text) {\r\n    text = text !== null && text !== void 0 ? text : '';\r\n    text = text.toString(); // might be a number\r\n    text = text.trim();\r\n    text = text.replace(/([a-z\\d])([A-Z]+)/g, '$1_$2');\r\n    text = text.replace(/[-\\s]+/g, '_').toLowerCase();\r\n    return text;\r\n}\r\nexports.underscore = underscore;\r\nfunction extname(text) {\r\n    const index = text.lastIndexOf('.');\r\n    const ext = text.substring(index, text.length);\r\n    return (index === -1) ? '' : ext;\r\n}\r\nexports.extname = extname;\r\nfunction humanize(text) {\r\n    text = text !== null && text !== void 0 ? text : '';\r\n    text = text.toString(); // might be a number\r\n    text = text.trim();\r\n    text = text.replace(extname(text), '');\r\n    text = underscore(text);\r\n    text = text.replace(/[\\W_]+/g, ' ');\r\n    return capitalize(text);\r\n}\r\nexports.humanize = humanize;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"ValidationContext.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/ValidationContext.js                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\r\nconst doValidation_js_1 = __importDefault(require(\"./doValidation.js\"));\r\nclass ValidationContext {\r\n    /**\r\n     * @param schema SimpleSchema instance to use for validation\r\n     * @param name Optional context name, accessible on context.name.\r\n     */\r\n    constructor(schema, name) {\r\n        this._validationErrors = [];\r\n        this.name = name;\r\n        this._simpleSchema = schema;\r\n        this._schema = schema.schema();\r\n        this._schemaKeys = Object.keys(this._schema);\r\n    }\r\n    setValidationErrors(errors) {\r\n        this._validationErrors = errors;\r\n    }\r\n    addValidationErrors(errors) {\r\n        errors.forEach((error) => this._validationErrors.push(error));\r\n    }\r\n    /**\r\n     * Reset the validationErrors array\r\n     */\r\n    reset() {\r\n        this.setValidationErrors([]);\r\n    }\r\n    /**\r\n     * @param key The key to get an error for\r\n     * @param genericKey The generic version of this key, if already known\r\n     * @returns The first validation error for this key, if any\r\n     */\r\n    getErrorForKey(key, genericKey = mongo_object_1.default.makeKeyGeneric(key)) {\r\n        const errors = this._validationErrors;\r\n        const errorForKey = errors.find((error) => error.name === key);\r\n        if (errorForKey != null)\r\n            return errorForKey;\r\n        return errors.find((error) => error.name === genericKey);\r\n    }\r\n    /**\r\n     * @param key The key to check validity for\r\n     * @param genericKey The generic version of this key, if already known\r\n     * @returns True if this key is currently invalid; otherwise false.\r\n     */\r\n    keyIsInvalid(key, genericKey = mongo_object_1.default.makeKeyGeneric(key)) {\r\n        return this.getErrorForKey(key, genericKey) != null;\r\n    }\r\n    /**\r\n     * @param key The key get the first error message for\r\n     * @param genericKey The generic version of this key, if already known\r\n     * @returns The message for the first error for this key, or an empty string\r\n     */\r\n    keyErrorMessage(key, genericKey = mongo_object_1.default.makeKeyGeneric(key)) {\r\n        const errorObj = this.getErrorForKey(key, genericKey);\r\n        if (errorObj == null)\r\n            return '';\r\n        return this._simpleSchema.messageForError(errorObj);\r\n    }\r\n    /**\r\n     * Validates the object against the SimpleSchema and sets a reactive array of error objects\r\n     * @param obj Object to be validated\r\n     * @param options Validation options\r\n     * @returns True if valid; otherwise false\r\n     */\r\n    validate(obj, { extendedCustomContext = {}, ignore: ignoreTypes = [], keys: keysToValidate, modifier: isModifier = false, mongoObject, upsert: isUpsert = false } = {}) {\r\n        const validationErrors = (0, doValidation_js_1.default)({\r\n            extendedCustomContext,\r\n            ignoreTypes,\r\n            isModifier,\r\n            isUpsert,\r\n            keysToValidate,\r\n            mongoObject,\r\n            obj,\r\n            schema: this._simpleSchema,\r\n            validationContext: this\r\n        });\r\n        if (keysToValidate != null) {\r\n            // We have only revalidated the listed keys, so if there\r\n            // are any other existing errors that are NOT in the keys list,\r\n            // we should keep these errors.\r\n            for (const error of this._validationErrors) {\r\n                const wasValidated = keysToValidate.some((key) => key === error.name || error.name.startsWith(`${key}.`));\r\n                if (!wasValidated)\r\n                    validationErrors.push(error);\r\n            }\r\n        }\r\n        this.setValidationErrors(validationErrors);\r\n        // Return true if it was valid; otherwise, return false\r\n        return validationErrors.length === 0;\r\n    }\r\n    isValid() {\r\n        return this._validationErrors.length === 0;\r\n    }\r\n    validationErrors() {\r\n        return this._validationErrors;\r\n    }\r\n    clean(doc, options = {}) {\r\n        return this._simpleSchema.clean(doc, options);\r\n    }\r\n}\r\nexports.default = ValidationContext;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"doValidation.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/doValidation.js                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\r\nconst SimpleSchema_js_1 = require(\"./SimpleSchema.js\");\r\nconst index_js_1 = require(\"./utility/index.js\");\r\nconst allowedValuesValidator_js_1 = __importDefault(require(\"./validation/allowedValuesValidator.js\"));\r\nconst requiredValidator_js_1 = __importDefault(require(\"./validation/requiredValidator.js\"));\r\nconst index_js_2 = __importDefault(require(\"./validation/typeValidator/index.js\"));\r\nfunction shouldCheck(key) {\r\n    if (key === '$pushAll') {\r\n        throw new Error('$pushAll is not supported; use $push + $each');\r\n    }\r\n    return !['$pull', '$pullAll', '$pop', '$slice'].includes(key);\r\n}\r\nfunction doValidation({ extendedCustomContext, ignoreTypes, isModifier, isUpsert, keysToValidate, mongoObject, obj, schema, validationContext }) {\r\n    // First do some basic checks of the object, and throw errors if necessary\r\n    if (obj == null || (typeof obj !== 'object' && typeof obj !== 'function')) {\r\n        throw new Error('The first argument of validate() must be an object');\r\n    }\r\n    if (!isModifier && (0, index_js_1.looksLikeModifier)(obj)) {\r\n        throw new Error('When the validation object contains mongo operators, you must set the modifier option to true');\r\n    }\r\n    function getFieldInfo(key) {\r\n        var _a;\r\n        // Create mongoObject if necessary, cache for speed\r\n        if (mongoObject == null)\r\n            mongoObject = new mongo_object_1.default(obj, schema.blackboxKeys());\r\n        const keyInfo = (_a = mongoObject.getInfoForKey(key)) !== null && _a !== void 0 ? _a : {\r\n            operator: null,\r\n            value: undefined\r\n        };\r\n        return Object.assign(Object.assign({}, keyInfo), { isSet: keyInfo.value !== undefined });\r\n    }\r\n    let validationErrors = [];\r\n    // Validation function called for each affected key\r\n    function validate(val, affectedKey, affectedKeyGeneric, def, op, isInArrayItemObject, isInSubObject) {\r\n        // Get the schema for this key, marking invalid if there isn't one.\r\n        if (def == null) {\r\n            // We don't need KEY_NOT_IN_SCHEMA error for $unset and we also don't need to continue\r\n            if (op === '$unset' ||\r\n                (op === '$currentDate' && affectedKey.endsWith('.$type'))) {\r\n                return;\r\n            }\r\n            validationErrors.push({\r\n                name: affectedKey,\r\n                type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\r\n                value: val\r\n            });\r\n            return;\r\n        }\r\n        // For $rename, make sure that the new name is allowed by the schema\r\n        if (op === '$rename' && !schema.allowsKey(val)) {\r\n            validationErrors.push({\r\n                name: val,\r\n                type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\r\n                value: null\r\n            });\r\n            return;\r\n        }\r\n        // Prepare the context object for the validator functions\r\n        const fieldParentNameWithEndDot = (0, index_js_1.getParentOfKey)(affectedKey, true);\r\n        const fieldParentName = fieldParentNameWithEndDot.slice(0, -1);\r\n        const fieldValidationErrors = [];\r\n        const validatorContext = Object.assign({ addValidationErrors(errors) {\r\n                errors.forEach((error) => fieldValidationErrors.push(error));\r\n            },\r\n            field(fName) {\r\n                return getFieldInfo(fName);\r\n            }, genericKey: affectedKeyGeneric, isInArrayItemObject,\r\n            isInSubObject,\r\n            isModifier, isSet: val !== undefined, key: affectedKey, obj, operator: op, parentField() {\r\n                return getFieldInfo(fieldParentName);\r\n            },\r\n            siblingField(fName) {\r\n                return getFieldInfo(fieldParentNameWithEndDot + fName);\r\n            },\r\n            validationContext, value: val, \r\n            // Value checks are not necessary for null or undefined values, except\r\n            // for non-optional null array items, or for $unset or $rename values\r\n            valueShouldBeChecked: op !== '$unset' &&\r\n                op !== '$rename' &&\r\n                ((val !== undefined && val !== null) ||\r\n                    ((affectedKeyGeneric === null || affectedKeyGeneric === void 0 ? void 0 : affectedKeyGeneric.slice(-2)) === '.$' &&\r\n                        val === null &&\r\n                        def.optional !== true)) }, (extendedCustomContext !== null && extendedCustomContext !== void 0 ? extendedCustomContext : {}));\r\n        const builtInValidators = [\r\n            requiredValidator_js_1.default,\r\n            index_js_2.default,\r\n            allowedValuesValidator_js_1.default\r\n        ];\r\n        const validators = builtInValidators\r\n            // @ts-expect-error\r\n            .concat(schema._validators)\r\n            // @ts-expect-error\r\n            .concat(SimpleSchema_js_1.SimpleSchema._validators);\r\n        // Loop through each of the definitions in the SimpleSchemaGroup.\r\n        // If any return true, we're valid.\r\n        const fieldIsValid = def.type.some((typeDef) => {\r\n            // If the type is SimpleSchema.Any, then it is valid\r\n            if (typeDef === SimpleSchema_js_1.SimpleSchema.Any)\r\n                return true;\r\n            const { type } = def, definitionWithoutType = __rest(def\r\n            // @ts-expect-error\r\n            , [\"type\"]); // eslint-disable-line no-unused-vars\r\n            // @ts-expect-error\r\n            const finalValidatorContext = Object.assign(Object.assign({}, validatorContext), { \r\n                // Take outer definition props like \"optional\" and \"label\"\r\n                // and add them to inner props like \"type\" and \"min\"\r\n                definition: Object.assign(Object.assign({}, definitionWithoutType), typeDef) });\r\n            // Add custom field validators to the list after the built-in\r\n            // validators but before the schema and global validators.\r\n            const fieldValidators = validators.slice(0);\r\n            const customFn = typeDef.custom;\r\n            if (customFn != null)\r\n                fieldValidators.splice(builtInValidators.length, 0, customFn);\r\n            // We use _.every just so that we don't continue running more validator\r\n            // functions after the first one returns false or an error string.\r\n            return fieldValidators.every((validator) => {\r\n                const result = validator.call(finalValidatorContext);\r\n                // If the validator returns a string, assume it is the\r\n                // error type.\r\n                if (typeof result === 'string') {\r\n                    fieldValidationErrors.push({\r\n                        name: affectedKey,\r\n                        type: result,\r\n                        value: val\r\n                    });\r\n                    return false;\r\n                }\r\n                // If the validator returns an object, assume it is an\r\n                // error object.\r\n                if (typeof result === 'object' && result !== null) {\r\n                    fieldValidationErrors.push(Object.assign({ name: affectedKey, value: val }, result));\r\n                    return false;\r\n                }\r\n                // If the validator returns false, assume they already\r\n                // called this.addValidationErrors within the function\r\n                if (result === false)\r\n                    return false;\r\n                // Any other return value we assume means it was valid\r\n                return true;\r\n            });\r\n        });\r\n        if (!fieldIsValid) {\r\n            validationErrors = validationErrors.concat(fieldValidationErrors);\r\n        }\r\n    }\r\n    // The recursive function\r\n    function checkObj({ val, affectedKey, operator = null, isInArrayItemObject = false, isInSubObject = false }) {\r\n        let affectedKeyGeneric;\r\n        let def;\r\n        if (affectedKey != null) {\r\n            // When we hit a blackbox key, we don't progress any further\r\n            if (schema.keyIsInBlackBox(affectedKey))\r\n                return;\r\n            // Make a generic version of the affected key, and use that\r\n            // to get the schema for this key.\r\n            affectedKeyGeneric = mongo_object_1.default.makeKeyGeneric(affectedKey);\r\n            if (affectedKeyGeneric === null)\r\n                throw new Error(`Failed to get generic key for affected key \"${affectedKey}\"`);\r\n            const shouldValidateKey = (keysToValidate == null) ||\r\n                keysToValidate.some((keyToValidate) => keyToValidate === affectedKey ||\r\n                    keyToValidate === affectedKeyGeneric ||\r\n                    affectedKey.startsWith(`${keyToValidate}.`) ||\r\n                    (affectedKeyGeneric === null || affectedKeyGeneric === void 0 ? void 0 : affectedKeyGeneric.startsWith(`${keyToValidate}.`)));\r\n            // Prepare the context object for the rule functions\r\n            const fieldParentNameWithEndDot = (0, index_js_1.getParentOfKey)(affectedKey, true);\r\n            const fieldParentName = fieldParentNameWithEndDot.slice(0, -1);\r\n            const functionsContext = Object.assign({ field(fName) {\r\n                    return getFieldInfo(fName);\r\n                }, genericKey: affectedKeyGeneric, isInArrayItemObject,\r\n                isInSubObject,\r\n                isModifier, isSet: val !== undefined, key: affectedKey, obj,\r\n                operator,\r\n                parentField() {\r\n                    return getFieldInfo(fieldParentName);\r\n                },\r\n                siblingField(fName) {\r\n                    return getFieldInfo(fieldParentNameWithEndDot + fName);\r\n                },\r\n                validationContext, value: val }, (extendedCustomContext !== null && extendedCustomContext !== void 0 ? extendedCustomContext : {}));\r\n            // Perform validation for this key\r\n            def = schema.getDefinition(affectedKey, null, functionsContext);\r\n            if (shouldValidateKey) {\r\n                validate(val, affectedKey, affectedKeyGeneric, def, operator, isInArrayItemObject, isInSubObject);\r\n            }\r\n        }\r\n        // If affectedKeyGeneric is undefined due to this being the first run of this\r\n        // function, objectKeys will return the top-level keys.\r\n        const childKeys = schema.objectKeys(affectedKeyGeneric);\r\n        // Temporarily convert missing objects to empty objects\r\n        // so that the looping code will be called and required\r\n        // descendent keys can be validated.\r\n        if ((val === undefined || val === null) &&\r\n            ((def == null) || (def.optional !== true && childKeys.length > 0))) {\r\n            val = {};\r\n        }\r\n        // Loop through arrays\r\n        if (Array.isArray(val)) {\r\n            val.forEach((v, i) => {\r\n                checkObj({\r\n                    val: v,\r\n                    affectedKey: `${affectedKey}.${i}`,\r\n                    operator\r\n                });\r\n            });\r\n        }\r\n        else if ((0, index_js_1.isObjectWeShouldTraverse)(val) &&\r\n            // @ts-expect-error\r\n            ((def == null) || !schema._blackboxKeys.has(affectedKey !== null && affectedKey !== void 0 ? affectedKey : ''))) {\r\n            // Loop through object keys\r\n            // Get list of present keys\r\n            const presentKeys = Object.keys(val);\r\n            // If this object is within an array, make sure we check for\r\n            // required as if it's not a modifier\r\n            isInArrayItemObject = (affectedKeyGeneric === null || affectedKeyGeneric === void 0 ? void 0 : affectedKeyGeneric.slice(-2)) === '.$';\r\n            const checkedKeys = [];\r\n            // Check all present keys plus all keys defined by the schema.\r\n            // This allows us to detect extra keys not allowed by the schema plus\r\n            // any missing required keys, and to run any custom functions for other keys.\r\n            /* eslint-disable no-restricted-syntax */\r\n            for (const key of [...presentKeys, ...childKeys]) {\r\n                // `childKeys` and `presentKeys` may contain the same keys, so make\r\n                // sure we run only once per unique key\r\n                if (checkedKeys.includes(key))\r\n                    continue;\r\n                checkedKeys.push(key);\r\n                checkObj({\r\n                    val: val[key],\r\n                    affectedKey: (0, index_js_1.appendAffectedKey)(affectedKey, key),\r\n                    operator,\r\n                    isInArrayItemObject,\r\n                    isInSubObject: true\r\n                });\r\n            }\r\n            /* eslint-enable no-restricted-syntax */\r\n        }\r\n    }\r\n    function checkModifier(mod) {\r\n        // Loop through operators\r\n        Object.keys(mod).forEach((op) => {\r\n            const opObj = mod[op];\r\n            // If non-operators are mixed in, throw error\r\n            if (op.slice(0, 1) !== '$') {\r\n                throw new Error(`Expected '${op}' to be a modifier operator like '$set'`);\r\n            }\r\n            if (shouldCheck(op)) {\r\n                // For an upsert, missing props would not be set if an insert is performed,\r\n                // so we check them all with undefined value to force any 'required' checks to fail\r\n                if (isUpsert && (op === '$set' || op === '$setOnInsert')) {\r\n                    const presentKeys = Object.keys(opObj);\r\n                    schema.objectKeys().forEach((schemaKey) => {\r\n                        if (!presentKeys.includes(schemaKey)) {\r\n                            checkObj({\r\n                                val: undefined,\r\n                                affectedKey: schemaKey,\r\n                                operator: op\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n                // Don't use forEach here because it will not properly handle an\r\n                // object that has a property named `length`\r\n                Object.keys(opObj).forEach((k) => {\r\n                    let v = opObj[k];\r\n                    if (op === '$push' || op === '$addToSet') {\r\n                        if (typeof v === 'object' && '$each' in v) {\r\n                            v = v.$each;\r\n                        }\r\n                        else {\r\n                            k = `${k}.0`;\r\n                        }\r\n                    }\r\n                    checkObj({\r\n                        val: v,\r\n                        affectedKey: k,\r\n                        operator: op\r\n                    });\r\n                });\r\n            }\r\n        });\r\n    }\r\n    // Kick off the validation\r\n    if (isModifier) {\r\n        checkModifier(obj);\r\n    }\r\n    else {\r\n        checkObj({ val: obj });\r\n    }\r\n    // Custom whole-doc validators\r\n    // @ts-expect-error\r\n    const docValidators = schema._docValidators.concat(\r\n    // @ts-expect-error\r\n    SimpleSchema_js_1.SimpleSchema._docValidators);\r\n    const docValidatorContext = Object.assign({ ignoreTypes,\r\n        isModifier,\r\n        isUpsert,\r\n        keysToValidate,\r\n        mongoObject,\r\n        obj,\r\n        schema,\r\n        validationContext }, (extendedCustomContext !== null && extendedCustomContext !== void 0 ? extendedCustomContext : {}));\r\n    docValidators.forEach((func) => {\r\n        const errors = func.call(docValidatorContext, obj);\r\n        if (!Array.isArray(errors)) {\r\n            throw new Error('Custom doc validator must return an array of error objects');\r\n        }\r\n        if (errors.length > 0)\r\n            validationErrors = validationErrors.concat(errors);\r\n    });\r\n    const addedFieldNames = [];\r\n    validationErrors = validationErrors.filter((errObj) => {\r\n        // Remove error types the user doesn't care about\r\n        if ((ignoreTypes === null || ignoreTypes === void 0 ? void 0 : ignoreTypes.includes(errObj.type)) === true)\r\n            return false;\r\n        // Make sure there is only one error per fieldName\r\n        if (addedFieldNames.includes(errObj.name))\r\n            return false;\r\n        addedFieldNames.push(errObj.name);\r\n        return true;\r\n    });\r\n    return validationErrors;\r\n}\r\nexports.default = doValidation;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"validation\":{\"allowedValuesValidator.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/allowedValuesValidator.js                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SimpleSchema_js_1 = require(\"../SimpleSchema.js\");\r\nfunction allowedValuesValidator() {\r\n    if (!this.valueShouldBeChecked)\r\n        return;\r\n    const { allowedValues } = this.definition;\r\n    if (allowedValues == null)\r\n        return;\r\n    let isAllowed;\r\n    // set defined in scope and allowedValues is its instance\r\n    if (typeof Set === 'function' && allowedValues instanceof Set) {\r\n        isAllowed = allowedValues.has(this.value);\r\n    }\r\n    else {\r\n        isAllowed = allowedValues.includes(this.value);\r\n    }\r\n    return isAllowed ? true : SimpleSchema_js_1.SimpleSchema.ErrorTypes.VALUE_NOT_ALLOWED;\r\n}\r\nexports.default = allowedValuesValidator;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"requiredValidator.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/requiredValidator.js                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SimpleSchema_js_1 = require(\"../SimpleSchema.js\");\r\nconst index_js_1 = require(\"../utility/index.js\");\r\n// Check for missing required values. The general logic is this:\r\n// * If the operator is $unset or $rename, it's invalid.\r\n// * If the value is null, it's invalid.\r\n// * If the value is undefined and one of the following are true, it's invalid:\r\n//     * We're validating a key of a sub-object.\r\n//     * We're validating a key of an object that is an array item.\r\n//     * We're validating a document (as opposed to a modifier).\r\n//     * We're validating a key under the $set operator in a modifier, and it's an upsert.\r\nfunction requiredValidator() {\r\n    const { definition, isInArrayItemObject, isInSubObject, key, obj, operator, value } = this;\r\n    const { optional } = definition;\r\n    if (optional === true)\r\n        return;\r\n    // If value is null, no matter what, we add required\r\n    if (value === null)\r\n        return SimpleSchema_js_1.SimpleSchema.ErrorTypes.REQUIRED;\r\n    // If operator would remove, we add required\r\n    if (operator === '$unset' || operator === '$rename') {\r\n        return SimpleSchema_js_1.SimpleSchema.ErrorTypes.REQUIRED;\r\n    }\r\n    // The rest of these apply only if the value is undefined\r\n    if (value !== undefined)\r\n        return;\r\n    // At this point, if it's a normal, non-modifier object, then a missing value is an error\r\n    if (operator == null)\r\n        return SimpleSchema_js_1.SimpleSchema.ErrorTypes.REQUIRED;\r\n    // Everything beyond this point deals with modifier objects only\r\n    // We can skip the required check for keys that are ancestors of those in $set or\r\n    // $setOnInsert because they will be created by MongoDB while setting.\r\n    const keysWithValueInSet = (0, index_js_1.getKeysWithValueInObj)(obj.$set, key);\r\n    if (keysWithValueInSet.length > 0)\r\n        return;\r\n    const keysWithValueInSetOnInsert = (0, index_js_1.getKeysWithValueInObj)(obj.$setOnInsert, key);\r\n    if (keysWithValueInSetOnInsert.length > 0)\r\n        return;\r\n    // In the case of $set and $setOnInsert, the value may be undefined here\r\n    // but it is set in another operator. So check that first.\r\n    const fieldInfo = this.field(key);\r\n    if (fieldInfo.isSet && fieldInfo.value !== null)\r\n        return;\r\n    // Required if in an array or sub object\r\n    if (isInArrayItemObject || isInSubObject) {\r\n        return SimpleSchema_js_1.SimpleSchema.ErrorTypes.REQUIRED;\r\n    }\r\n    // If we've got this far with an undefined $set or $setOnInsert value, it's a required error.\r\n    if (operator === '$set' || operator === '$setOnInsert') {\r\n        return SimpleSchema_js_1.SimpleSchema.ErrorTypes.REQUIRED;\r\n    }\r\n}\r\nexports.default = requiredValidator;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"typeValidator\":{\"index.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/typeValidator/index.js                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isValueTypeValid = exports.checkValueType = void 0;\r\nconst SimpleSchema_js_1 = require(\"../../SimpleSchema.js\");\r\nconst checkArrayValue_js_1 = __importDefault(require(\"./checkArrayValue.js\"));\r\nconst checkDateValue_js_1 = __importDefault(require(\"./checkDateValue.js\"));\r\nconst checkNumberValue_js_1 = __importDefault(require(\"./checkNumberValue.js\"));\r\nconst checkStringValue_js_1 = __importDefault(require(\"./checkStringValue.js\"));\r\nfunction checkValueType(info) {\r\n    const { definition: def, operator: op, value, valueShouldBeChecked } = info;\r\n    if (!valueShouldBeChecked)\r\n        return;\r\n    const expectedType = def.type;\r\n    if (expectedType === String)\r\n        return (0, checkStringValue_js_1.default)(def, value);\r\n    if (expectedType === Number)\r\n        return (0, checkNumberValue_js_1.default)(def, value, op, false);\r\n    if (expectedType === SimpleSchema_js_1.SimpleSchema.Integer)\r\n        return (0, checkNumberValue_js_1.default)(def, value, op, true);\r\n    if (expectedType === Boolean) {\r\n        // Is it a boolean?\r\n        if (typeof value === 'boolean')\r\n            return;\r\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE, dataType: 'Boolean' };\r\n    }\r\n    if (expectedType === Object || SimpleSchema_js_1.SimpleSchema.isSimpleSchema(expectedType)) {\r\n        // Is it an object?\r\n        if (value === Object(value) &&\r\n            typeof value[Symbol.iterator] !== 'function' &&\r\n            !(value instanceof Date)) {\r\n            return;\r\n        }\r\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE, dataType: 'Object' };\r\n    }\r\n    if (expectedType === Array)\r\n        return (0, checkArrayValue_js_1.default)(def, value);\r\n    if (expectedType instanceof Function) {\r\n        // Generic constructor checks\r\n        if (!(value instanceof expectedType)) {\r\n            // https://docs.mongodb.com/manual/reference/operator/update/currentDate/\r\n            const dateTypeIsOkay = expectedType === Date &&\r\n                op === '$currentDate' &&\r\n                (value === true || JSON.stringify(value) === '{\"$type\":\"date\"}');\r\n            if (expectedType !== Date || !dateTypeIsOkay) {\r\n                return {\r\n                    type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE,\r\n                    dataType: expectedType.name\r\n                };\r\n            }\r\n        }\r\n        // Date checks\r\n        if (expectedType === Date) {\r\n            // https://docs.mongodb.com/manual/reference/operator/update/currentDate/\r\n            if (op === '$currentDate') {\r\n                return (0, checkDateValue_js_1.default)(def, new Date());\r\n            }\r\n            return (0, checkDateValue_js_1.default)(def, value);\r\n        }\r\n    }\r\n}\r\nexports.checkValueType = checkValueType;\r\nfunction isValueTypeValid(typeDefinitions, value, operator) {\r\n    return typeDefinitions.some((definition) => {\r\n        const typeValidationError = checkValueType({\r\n            valueShouldBeChecked: true,\r\n            definition,\r\n            value,\r\n            operator\r\n        });\r\n        return typeValidationError === undefined;\r\n    });\r\n}\r\nexports.isValueTypeValid = isValueTypeValid;\r\nfunction typeValidator() {\r\n    return checkValueType(this);\r\n}\r\nexports.default = typeValidator;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"checkArrayValue.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/typeValidator/checkArrayValue.js                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SimpleSchema_js_1 = require(\"../../SimpleSchema.js\");\r\nfunction checkArrayValue(def, value) {\r\n    // Is it an array?\r\n    if (!Array.isArray(value)) {\r\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE, dataType: 'Array' };\r\n    }\r\n    // Are there fewer than the minimum number of items in the array?\r\n    if (def.minCount != null && value.length < def.minCount) {\r\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MIN_COUNT, minCount: def.minCount };\r\n    }\r\n    // Are there more than the maximum number of items in the array?\r\n    if (def.maxCount != null && value.length > def.maxCount) {\r\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MAX_COUNT, maxCount: def.maxCount };\r\n    }\r\n}\r\nexports.default = checkArrayValue;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"checkDateValue.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/typeValidator/checkDateValue.js                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SimpleSchema_js_1 = require(\"../../SimpleSchema.js\");\r\nconst index_js_1 = require(\"../../utility/index.js\");\r\nfunction checkDateValue(def, value) {\r\n    // Is it an invalid date?\r\n    if (isNaN(value.getTime())) {\r\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.BAD_DATE };\r\n    }\r\n    // Is it earlier than the minimum date?\r\n    if (def.min !== undefined &&\r\n        typeof def.min.getTime === 'function' &&\r\n        def.min.getTime() > value.getTime()) {\r\n        return {\r\n            type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MIN_DATE,\r\n            min: (0, index_js_1.dateToDateString)(def.min)\r\n        };\r\n    }\r\n    // Is it later than the maximum date?\r\n    if (def.max !== undefined &&\r\n        typeof def.max.getTime === 'function' &&\r\n        def.max.getTime() < value.getTime()) {\r\n        return {\r\n            type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MAX_DATE,\r\n            max: (0, index_js_1.dateToDateString)(def.max)\r\n        };\r\n    }\r\n}\r\nexports.default = checkDateValue;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"checkNumberValue.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/typeValidator/checkNumberValue.js                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SimpleSchema_js_1 = require(\"../../SimpleSchema.js\");\r\nfunction checkNumberValue(def, value, op, expectsInteger) {\r\n    // Is it a valid number?\r\n    if (typeof value !== 'number' || isNaN(value)) {\r\n        return {\r\n            type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE,\r\n            dataType: expectsInteger ? 'Integer' : 'Number'\r\n        };\r\n    }\r\n    // Assuming we are not incrementing, is the value less than the maximum value?\r\n    if (op !== '$inc' &&\r\n        def.max !== null &&\r\n        (def.exclusiveMax === true\r\n            ? def.max <= value\r\n            : def.max < value)) {\r\n        return {\r\n            type: def.exclusiveMax === true\r\n                ? SimpleSchema_js_1.SimpleSchema.ErrorTypes.MAX_NUMBER_EXCLUSIVE\r\n                : SimpleSchema_js_1.SimpleSchema.ErrorTypes.MAX_NUMBER,\r\n            max: def.max\r\n        };\r\n    }\r\n    // Assuming we are not incrementing, is the value more than the minimum value?\r\n    if (op !== '$inc' &&\r\n        def.min !== null &&\r\n        (def.exclusiveMin === true\r\n            ? def.min >= value\r\n            : def.min > value)) {\r\n        return {\r\n            type: def.exclusiveMin === true\r\n                ? SimpleSchema_js_1.SimpleSchema.ErrorTypes.MIN_NUMBER_EXCLUSIVE\r\n                : SimpleSchema_js_1.SimpleSchema.ErrorTypes.MIN_NUMBER,\r\n            min: def.min\r\n        };\r\n    }\r\n    // Is it an integer if we expect an integer?\r\n    if (expectsInteger && !Number.isInteger(value)) {\r\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MUST_BE_INTEGER };\r\n    }\r\n}\r\nexports.default = checkNumberValue;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"checkStringValue.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/typeValidator/checkStringValue.js                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SimpleSchema_js_1 = require(\"../../SimpleSchema.js\");\r\nfunction checkStringValue(def, value) {\r\n    // Is it a String?\r\n    if (typeof value !== 'string') {\r\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE, dataType: 'String' };\r\n    }\r\n    // Is the string too long?\r\n    if (def.max !== null && def.max < value.length) {\r\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MAX_STRING, max: def.max };\r\n    }\r\n    // Is the string too short?\r\n    if (def.min !== null && def.min > value.length) {\r\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MIN_STRING, min: def.min };\r\n    }\r\n    // Does the string match the regular expression?\r\n    if ((def.skipRegExCheckForEmptyStrings !== true || value !== '') &&\r\n        def.regEx instanceof RegExp &&\r\n        !def.regEx.test(value)) {\r\n        return {\r\n            type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.FAILED_REGULAR_EXPRESSION,\r\n            regExp: def.regEx.toString()\r\n        };\r\n    }\r\n    // If regEx is an array of regular expressions, does the string match all of them?\r\n    if (Array.isArray(def.regEx)) {\r\n        let regExError;\r\n        def.regEx.every((re) => {\r\n            if (!re.test(value)) {\r\n                regExError = {\r\n                    type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.FAILED_REGULAR_EXPRESSION,\r\n                    regExp: re.toString()\r\n                };\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n        if (regExError !== undefined)\r\n            return regExError;\r\n    }\r\n}\r\nexports.default = checkStringValue;\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}},\"clone\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/clone/package.json                                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"name\": \"clone\",\n  \"version\": \"2.1.2\",\n  \"main\": \"clone.js\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"clone.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/clone/clone.js                                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"mongo-object\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/mongo-object/package.json                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"name\": \"mongo-object\",\n  \"version\": \"3.0.0\",\n  \"main\": \"./dist/index.js\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"dist\":{\"index.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/mongo-object/dist/index.js                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({MongoObject:()=>MongoObject});let MongoObject;module.link('./mongo-object.js',{default(v){MongoObject=v}},0);module.link('./util.js',{appendAffectedKey:\"appendAffectedKey\",cleanNulls:\"cleanNulls\",expandKey:\"expandKey\",extractOp:\"extractOp\",genericKeyAffectsOtherGenericKey:\"genericKeyAffectsOtherGenericKey\",isBasicObject:\"isBasicObject\",keyToPosition:\"keyToPosition\",makeKeyGeneric:\"makeKeyGeneric\",reportNulls:\"reportNulls\"},1);\r\n\r\n\r\nmodule.exportDefault(MongoObject);\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"mongo-object.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/mongo-object/dist/mongo-object.js                                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({default:()=>MongoObject});let appendAffectedKey,cleanNulls,each,expandKey,extractOp,genericKeyAffectsOtherGenericKey,isBasicObject,isEmpty,isObject,keyToPosition,makeKeyGeneric,reportNulls;module.link('./util.js',{appendAffectedKey(v){appendAffectedKey=v},cleanNulls(v){cleanNulls=v},each(v){each=v},expandKey(v){expandKey=v},extractOp(v){extractOp=v},genericKeyAffectsOtherGenericKey(v){genericKeyAffectsOtherGenericKey=v},isBasicObject(v){isBasicObject=v},isEmpty(v){isEmpty=v},isObject(v){isObject=v},keyToPosition(v){keyToPosition=v},makeKeyGeneric(v){makeKeyGeneric=v},reportNulls(v){reportNulls=v}},0);\r\nconst REMOVED_MARKER = '______MONGO_OBJECT_REMOVED______';\r\nclass MongoObject {\r\n    _affectedKeys = {};\r\n    _arrayItemPositions = [];\r\n    _blackboxKeys = [];\r\n    _genericAffectedKeys = {};\r\n    _obj;\r\n    _objectPositions = [];\r\n    _parentPositions = [];\r\n    _positionsByGenericKey = {};\r\n    _positionsInsideArrays = [];\r\n    _positionsThatCreateGenericKey = {};\r\n    /*\r\n     * @constructor\r\n     * @param obj\r\n     * @param blackboxKeys A list of the names of keys that shouldn't be traversed\r\n     * @returns {undefined}\r\n     *\r\n     * Creates a new MongoObject instance. The object passed as the first argument\r\n     * will be modified in place by calls to instance methods. Also, immediately\r\n     * upon creation of the instance, the object will have any `undefined` keys\r\n     * removed recursively.\r\n     */\r\n    constructor(obj, blackboxKeys = []) {\r\n        this._obj = obj;\r\n        this._blackboxKeys = blackboxKeys;\r\n        this._reParseObj();\r\n    }\r\n    _reParseObj() {\r\n        const blackboxKeys = this._blackboxKeys;\r\n        this._affectedKeys = {};\r\n        this._genericAffectedKeys = {};\r\n        this._positionsByGenericKey = {};\r\n        this._positionsThatCreateGenericKey = {};\r\n        this._parentPositions = [];\r\n        this._positionsInsideArrays = [];\r\n        this._objectPositions = [];\r\n        this._arrayItemPositions = [];\r\n        function parseObj(self, val, currentPosition, affectedKey, operator, adjusted, isWithinArray) {\r\n            // Adjust for first-level modifier operators\r\n            if (!operator && affectedKey && affectedKey.substring(0, 1) === '$') {\r\n                operator = affectedKey;\r\n                affectedKey = null;\r\n            }\r\n            let affectedKeyIsBlackBox = false;\r\n            let stop = false;\r\n            if (affectedKey) {\r\n                // Adjust for $push and $addToSet and $pull and $pop\r\n                if (!adjusted) {\r\n                    if (operator === '$push'\r\n                        || operator === '$addToSet'\r\n                        || operator === '$pop') {\r\n                        // Adjust for $each\r\n                        // We can simply jump forward and pretend like the $each array\r\n                        // is the array for the field. This has the added benefit of\r\n                        // skipping past any $slice, which we also don't care about.\r\n                        if (isBasicObject(val) && '$each' in val) {\r\n                            val = val.$each;\r\n                            currentPosition = `${currentPosition}[$each]`;\r\n                        }\r\n                        else {\r\n                            affectedKey = `${affectedKey}.0`;\r\n                        }\r\n                        adjusted = true;\r\n                    }\r\n                    else if (operator === '$pull') {\r\n                        affectedKey = `${affectedKey}.0`;\r\n                        if (isBasicObject(val)) {\r\n                            stop = true;\r\n                        }\r\n                        adjusted = true;\r\n                    }\r\n                }\r\n                // Make generic key\r\n                const affectedKeyGeneric = makeKeyGeneric(affectedKey);\r\n                if (affectedKeyGeneric === null)\r\n                    throw new Error(`Failed to get generic key for key \"${affectedKey}\"`);\r\n                // Determine whether affected key should be treated as a black box\r\n                affectedKeyIsBlackBox = affectedKeyGeneric !== null\r\n                    && blackboxKeys.indexOf(affectedKeyGeneric) > -1;\r\n                // Mark that this position affects this generic and non-generic key\r\n                if (currentPosition) {\r\n                    self._affectedKeys[currentPosition] = affectedKey;\r\n                    self._genericAffectedKeys[currentPosition] = affectedKeyGeneric;\r\n                    const positionInfo = {\r\n                        key: affectedKey,\r\n                        operator: operator || null,\r\n                        position: currentPosition,\r\n                    };\r\n                    if (!self._positionsByGenericKey[affectedKeyGeneric])\r\n                        self._positionsByGenericKey[affectedKeyGeneric] = [];\r\n                    self._positionsByGenericKey[affectedKeyGeneric].push(positionInfo);\r\n                    // Operators other than $unset will cause ancestor object keys to\r\n                    // be auto-created.\r\n                    if (operator && operator !== '$unset') {\r\n                        MongoObject.objectsThatGenericKeyWillCreate(affectedKeyGeneric).forEach((objGenericKey) => {\r\n                            if (!self._positionsThatCreateGenericKey[objGenericKey]) {\r\n                                self._positionsThatCreateGenericKey[objGenericKey] = [];\r\n                            }\r\n                            self._positionsThatCreateGenericKey[objGenericKey].push(positionInfo);\r\n                        });\r\n                    }\r\n                    // If we're within an array, mark this position so we can omit it from flat docs\r\n                    if (isWithinArray)\r\n                        self._positionsInsideArrays.push(currentPosition);\r\n                }\r\n            }\r\n            if (stop)\r\n                return;\r\n            // Loop through arrays\r\n            if (Array.isArray(val) && val.length > 0) {\r\n                if (currentPosition) {\r\n                    // Mark positions with arrays that should be ignored when we want endpoints only\r\n                    self._parentPositions.push(currentPosition);\r\n                }\r\n                // Loop\r\n                val.forEach((v, i) => {\r\n                    if (currentPosition)\r\n                        self._arrayItemPositions.push(`${currentPosition}[${i}]`);\r\n                    parseObj(self, v, currentPosition ? `${currentPosition}[${i}]` : String(i), `${affectedKey}.${i}`, operator, adjusted, true);\r\n                });\r\n            }\r\n            else if ((isBasicObject(val) && !affectedKeyIsBlackBox)\r\n                || !currentPosition) {\r\n                // Loop through object keys, only for basic objects,\r\n                // but always for the passed-in object, even if it\r\n                // is a custom object.\r\n                if (currentPosition && !isEmpty(val)) {\r\n                    // Mark positions with objects that should be ignored when we want endpoints only\r\n                    self._parentPositions.push(currentPosition);\r\n                    // Mark positions with objects that should be left out of flat docs.\r\n                    self._objectPositions.push(currentPosition);\r\n                }\r\n                // Loop\r\n                Object.keys(val).forEach((k) => {\r\n                    const v = val[k];\r\n                    if (v === undefined) {\r\n                        delete val[k];\r\n                    }\r\n                    else if (k !== '$slice') {\r\n                        parseObj(self, v, currentPosition ? `${currentPosition}[${k}]` : k, appendAffectedKey(affectedKey, k), operator, adjusted, isWithinArray);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        parseObj(this, this._obj);\r\n    }\r\n    /**\r\n     * @param func\r\n     * @param [options]\r\n     * @param [options.endPointsOnly=true] - Only call function for endpoints and not for nodes that contain other nodes\r\n     * @returns\r\n     *\r\n     * Runs a function for each endpoint node in the object tree, including all items in every array.\r\n     * The function arguments are\r\n     * (1) the value at this node\r\n     * (2) a string representing the node position\r\n     * (3) the representation of what would be changed in mongo, using mongo dot notation\r\n     * (4) the generic equivalent of argument 3, with '$' instead of numeric pieces\r\n     */\r\n    forEachNode(func, { endPointsOnly = true } = {}) {\r\n        if (typeof func !== 'function')\r\n            throw new Error('filter requires a loop function');\r\n        const updatedValues = {};\r\n        Object.keys(this._affectedKeys).forEach((position) => {\r\n            if (endPointsOnly && this._parentPositions.indexOf(position) > -1)\r\n                return; // Only endpoints\r\n            func.call({\r\n                value: this.getValueForPosition(position),\r\n                isArrayItem: this._arrayItemPositions.indexOf(position) > -1,\r\n                operator: extractOp(position),\r\n                position,\r\n                key: this._affectedKeys[position],\r\n                genericKey: this._genericAffectedKeys[position],\r\n                updateValue: (newVal) => {\r\n                    updatedValues[position] = newVal;\r\n                },\r\n                remove: () => {\r\n                    updatedValues[position] = undefined;\r\n                },\r\n            });\r\n        });\r\n        // Actually update/remove values as instructed\r\n        Object.keys(updatedValues).forEach((position) => {\r\n            this.setValueForPosition(position, updatedValues[position]);\r\n        });\r\n    }\r\n    getValueForPosition(position) {\r\n        const subkeys = position.split('[');\r\n        let current = this._obj;\r\n        const ln = subkeys.length;\r\n        for (let i = 0; i < ln; i++) {\r\n            let subkey = subkeys[i];\r\n            // If the subkey ends in ']', remove the ending\r\n            if (subkey.slice(-1) === ']')\r\n                subkey = subkey.slice(0, -1);\r\n            current = current[subkey];\r\n            if (!Array.isArray(current) && !isBasicObject(current) && i < ln - 1)\r\n                return;\r\n        }\r\n        if (current === REMOVED_MARKER)\r\n            return;\r\n        return current;\r\n    }\r\n    /**\r\n     * @param position\r\n     * @param value\r\n     */\r\n    setValueForPosition(position, value) {\r\n        const subkeys = position.split('[');\r\n        let current = this._obj;\r\n        const ln = subkeys.length;\r\n        let createdObjectsOrArrays = false;\r\n        let affectedKey = '';\r\n        for (let i = 0; i < ln; i++) {\r\n            let subkey = subkeys[i];\r\n            // If the subkey ends in \"]\", remove the ending\r\n            if (subkey.slice(-1) === ']')\r\n                subkey = subkey.slice(0, -1);\r\n            // We don't store modifiers\r\n            if (subkey && subkey.substring(0, 1) !== '$') {\r\n                affectedKey = appendAffectedKey(affectedKey, subkey);\r\n            }\r\n            // If we've reached the key in the object tree that needs setting or\r\n            // deleting, do it.\r\n            if (i === ln - 1) {\r\n                // If value is undefined, delete the property\r\n                if (value === undefined) {\r\n                    if (Array.isArray(current)) {\r\n                        // We can't just delete it because indexes in the position strings will be off\r\n                        // We will mark it uniquely and then parse this elsewhere\r\n                        current[Number(subkey)] = REMOVED_MARKER;\r\n                    }\r\n                    else {\r\n                        delete current[subkey];\r\n                    }\r\n                }\r\n                else {\r\n                    current[subkey] = value;\r\n                }\r\n                this._affectedKeys[position] = affectedKey;\r\n            }\r\n            else {\r\n                // Otherwise attempt to keep moving deeper into the object.\r\n                // If we're setting (as opposed to deleting) a key and we hit a place\r\n                // in the ancestor chain where the keys are not yet created, create them.\r\n                if (current[subkey] === undefined && value !== undefined) {\r\n                    // See if the next piece is a number\r\n                    const nextPiece = subkeys[i + 1];\r\n                    current[subkey] = Number.isNaN(parseInt(nextPiece, 10)) ? {} : [];\r\n                    createdObjectsOrArrays = true;\r\n                }\r\n                // Move deeper into the object\r\n                current = current[subkey];\r\n                // If we can go no further, then quit\r\n                if (!Array.isArray(current) && !isBasicObject(current) && i < ln - 1)\r\n                    return;\r\n            }\r\n        }\r\n        // If there are now new arrays or objects in the main object, we need to reparse it\r\n        if (createdObjectsOrArrays\r\n            || Array.isArray(value)\r\n            || isBasicObject(value)) {\r\n            this._reParseObj();\r\n        }\r\n    }\r\n    removeValueForPosition(position) {\r\n        this.setValueForPosition(position, undefined);\r\n    }\r\n    getKeyForPosition(position) {\r\n        return this._affectedKeys[position];\r\n    }\r\n    getGenericKeyForPosition(position) {\r\n        return this._genericAffectedKeys[position];\r\n    }\r\n    /**\r\n     * @param key Non-generic key\r\n     * @returns The value and operator of the requested non-generic key.\r\n     *   Example: {value: 1, operator: \"$pull\"}\r\n     */\r\n    getInfoForKey(key) {\r\n        // Get the info\r\n        const position = this.getPositionForKey(key);\r\n        if (position) {\r\n            return {\r\n                value: this.getValueForPosition(position),\r\n                operator: extractOp(position),\r\n            };\r\n        }\r\n        // If we haven't returned yet, check to see if there is an array value\r\n        // corresponding to this key\r\n        // We find the first item within the array, strip the last piece off the\r\n        // position string, and then return whatever is at that new position in\r\n        // the original object.\r\n        const positions = this.getPositionsForGenericKey(`${key}.$`);\r\n        for (let index = 0; index < positions.length; index++) {\r\n            const pos = positions[index];\r\n            let value = this.getValueForPosition(pos);\r\n            if (value === undefined) {\r\n                const parentPosition = pos.slice(0, pos.lastIndexOf('['));\r\n                value = this.getValueForPosition(parentPosition);\r\n            }\r\n            if (value !== undefined) {\r\n                return {\r\n                    value,\r\n                    operator: extractOp(pos),\r\n                };\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @method MongoObject.getPositionForKey\r\n     * @param {String} key - Non-generic key\r\n     * @returns The position string for the place in the object that\r\n     *   affects the requested non-generic key.\r\n     *   Example: 'foo[bar][0]'\r\n     */\r\n    getPositionForKey(key) {\r\n        const positions = Object.getOwnPropertyNames(this._affectedKeys);\r\n        for (let index = 0; index < positions.length; index++) {\r\n            const position = positions[index];\r\n            // We return the first one we find. While it's\r\n            // possible that multiple update operators could\r\n            // affect the same non-generic key, we'll assume that's not the case.\r\n            if (this._affectedKeys[position] === key)\r\n                return position;\r\n        }\r\n    }\r\n    /**\r\n     * @param genericKey Generic key\r\n     * @returns An array of position strings for the places in the object that\r\n     *   affect the requested generic key.\r\n     *   Example: ['foo[bar][0]']\r\n     */\r\n    getPositionsForGenericKey(genericKey) {\r\n        return this.getPositionsInfoForGenericKey(genericKey).map((p) => p.position);\r\n    }\r\n    /**\r\n     * @param genericKey Generic key\r\n     * @returns An array of position info for the places in the object that\r\n     *   affect the requested generic key.\r\n     */\r\n    getPositionsInfoForGenericKey(genericKey) {\r\n        let positions = this._positionsByGenericKey[genericKey];\r\n        if (!positions || positions.length === 0)\r\n            positions = this._positionsByGenericKey[`${genericKey}.$`];\r\n        if (!positions || positions.length === 0)\r\n            positions = [];\r\n        return positions.map((info) => ({\r\n            value: this.getValueForPosition(info.position),\r\n            ...info,\r\n        }));\r\n    }\r\n    getPositionsThatCreateGenericKey(genericKey) {\r\n        return this._positionsThatCreateGenericKey[genericKey] || [];\r\n    }\r\n    /**\r\n     * @deprecated Use getInfoForKey\r\n     * @param {String} key - Non-generic key\r\n     * @returns The value of the requested non-generic key\r\n     */\r\n    getValueForKey(key) {\r\n        const position = this.getPositionForKey(key);\r\n        if (position)\r\n            return this.getValueForPosition(position);\r\n    }\r\n    /**\r\n     * Adds `key` with value `val` under operator `op` to the source object.\r\n     *\r\n     * @param key Key to set\r\n     * @param val Value to give this key\r\n     * @param op Operator under which to set it, or `null` for a non-modifier object\r\n     * @returns\r\n     */\r\n    addKey(key, val, op) {\r\n        const position = op ? `${op}[${key}]` : keyToPosition(key);\r\n        this.setValueForPosition(position, val);\r\n    }\r\n    /**\r\n     * Removes anything that affects any of the generic keys in the list\r\n     */\r\n    removeGenericKeys(keys) {\r\n        Object.getOwnPropertyNames(this._genericAffectedKeys).forEach((position) => {\r\n            const genericKey = this._genericAffectedKeys[position];\r\n            if (genericKey !== null && keys.indexOf(genericKey) > -1) {\r\n                this.removeValueForPosition(position);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Removes anything that affects the requested generic key\r\n     */\r\n    removeGenericKey(key) {\r\n        Object.getOwnPropertyNames(this._genericAffectedKeys).forEach((position) => {\r\n            if (this._genericAffectedKeys[position] === key) {\r\n                this.removeValueForPosition(position);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Removes anything that affects the requested non-generic key\r\n     */\r\n    removeKey(key) {\r\n        // We don't use getPositionForKey here because we want to be sure to\r\n        // remove for all positions if there are multiple.\r\n        Object.getOwnPropertyNames(this._affectedKeys).forEach((position) => {\r\n            if (this._affectedKeys[position] === key) {\r\n                this.removeValueForPosition(position);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Removes anything that affects any of the non-generic keys in the list\r\n     */\r\n    removeKeys(keys) {\r\n        keys.forEach((key) => this.removeKey(key));\r\n    }\r\n    /**\r\n     * Passes all affected keys to a test function, which\r\n     * should return false to remove whatever is affecting that key\r\n     */\r\n    filterGenericKeys(test) {\r\n        const checkedKeys = [];\r\n        const keysToRemove = [];\r\n        Object.getOwnPropertyNames(this._genericAffectedKeys).forEach((position) => {\r\n            const genericKey = this._genericAffectedKeys[position];\r\n            if (genericKey !== null && checkedKeys.indexOf(genericKey) === -1) {\r\n                checkedKeys.push(genericKey);\r\n                if (genericKey && !test(genericKey)) {\r\n                    keysToRemove.push(genericKey);\r\n                }\r\n            }\r\n        });\r\n        keysToRemove.forEach((key) => this.removeGenericKey(key));\r\n    }\r\n    /**\r\n     * Sets the value for every place in the object that affects\r\n     * the requested non-generic key\r\n     */\r\n    setValueForKey(key, val) {\r\n        // We don't use getPositionForKey here because we want to be sure to\r\n        // set the value for all positions if there are multiple.\r\n        Object.getOwnPropertyNames(this._affectedKeys).forEach((position) => {\r\n            if (this._affectedKeys[position] === key) {\r\n                this.setValueForPosition(position, val);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Sets the value for every place in the object that affects\r\n     * the requested generic key\r\n     */\r\n    setValueForGenericKey(key, val) {\r\n        // We don't use getPositionForKey here because we want to be sure to\r\n        // set the value for all positions if there are multiple.\r\n        Object.getOwnPropertyNames(this._genericAffectedKeys).forEach((position) => {\r\n            if (this._genericAffectedKeys[position] === key) {\r\n                this.setValueForPosition(position, val);\r\n            }\r\n        });\r\n    }\r\n    removeArrayItems() {\r\n        // Traverse and pull out removed array items at this point\r\n        function traverse(obj) {\r\n            each(obj, (val, indexOrProp) => {\r\n                // Move deeper into the object\r\n                const next = obj[indexOrProp];\r\n                // If we can go no further, then quit\r\n                if (isBasicObject(next)) {\r\n                    traverse(next);\r\n                }\r\n                else if (Array.isArray(next)) {\r\n                    obj[indexOrProp] = next.filter((item) => item !== REMOVED_MARKER);\r\n                    traverse(obj[indexOrProp]);\r\n                }\r\n            });\r\n        }\r\n        traverse(this._obj);\r\n    }\r\n    /**\r\n     * Get the source object, potentially modified by other method calls on this\r\n     * MongoObject instance.\r\n     */\r\n    getObject() {\r\n        return this._obj;\r\n    }\r\n    /**\r\n     * Gets a flat object based on the MongoObject instance.\r\n     * In a flat object, the key is the name of the non-generic affectedKey,\r\n     * with mongo dot notation if necessary, and the value is the value for\r\n     * that key.\r\n     *\r\n     * With `keepArrays: true`, we don't flatten within arrays. Currently\r\n     * MongoDB does not see a key such as `a.0.b` and automatically assume\r\n     * an array. Instead it would create an object with key '0' if there\r\n     * wasn't already an array saved as the value of `a`, which is rarely\r\n     * if ever what we actually want. To avoid this confusion, we\r\n     * set entire arrays.\r\n     */\r\n    getFlatObject({ keepArrays = false } = {}) {\r\n        const newObj = {};\r\n        Object.keys(this._affectedKeys).forEach((position) => {\r\n            const affectedKey = this._affectedKeys[position];\r\n            if (typeof affectedKey === 'string'\r\n                && ((keepArrays === true\r\n                    && this._positionsInsideArrays.indexOf(position) === -1\r\n                    && this._objectPositions.indexOf(position) === -1)\r\n                    || (keepArrays !== true\r\n                        && this._parentPositions.indexOf(position) === -1))) {\r\n                newObj[affectedKey] = this.getValueForPosition(position);\r\n            }\r\n        });\r\n        return newObj;\r\n    }\r\n    /**\r\n     * @method MongoObject.affectsKey\r\n     * @param key Key to test\r\n     * @returns True if the non-generic key is affected by this object\r\n     */\r\n    affectsKey(key) {\r\n        return !!this.getPositionForKey(key);\r\n    }\r\n    /**\r\n     * @method MongoObject.affectsGenericKey\r\n     * @param key Key to test\r\n     * @returns True if the generic key is affected by this object\r\n     */\r\n    affectsGenericKey(key) {\r\n        const positions = Object.getOwnPropertyNames(this._genericAffectedKeys);\r\n        for (let index = 0; index < positions.length; index++) {\r\n            const position = positions[index];\r\n            if (this._genericAffectedKeys[position] === key)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * @method MongoObject.affectsGenericKeyImplicit\r\n     * @param key Key to test\r\n     * @returns Like affectsGenericKey, but will return true if a child key is affected\r\n     */\r\n    affectsGenericKeyImplicit(key) {\r\n        const positions = Object.getOwnPropertyNames(this._genericAffectedKeys);\r\n        for (let index = 0; index < positions.length; index++) {\r\n            const position = positions[index];\r\n            const affectedKey = this._genericAffectedKeys[position];\r\n            if (affectedKey !== null\r\n                && genericKeyAffectsOtherGenericKey(key, affectedKey))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    /* STATIC */\r\n    static _keyToPosition = keyToPosition;\r\n    static cleanNulls = cleanNulls;\r\n    static expandKey = expandKey;\r\n    static isBasicObject = isBasicObject;\r\n    static makeKeyGeneric = makeKeyGeneric;\r\n    static reportNulls = reportNulls;\r\n    /**\r\n     * This is different from MongoObject.prototype.getKeyForPosition in that\r\n     * this method does not depend on the requested position actually being\r\n     * present in any particular MongoObject.\r\n     *\r\n     * @method MongoObject._positionToKey\r\n     * @param position\r\n     * @returns The key that this position in an object would affect.\r\n     */\r\n    static _positionToKey(position) {\r\n        // XXX Probably a better way to do this, but this is\r\n        // foolproof for now.\r\n        const mDoc = new MongoObject({});\r\n        mDoc.setValueForPosition(position, 1); // Value doesn't matter\r\n        return mDoc.getKeyForPosition(position);\r\n    }\r\n    /**\r\n     * @method MongoObject.docToModifier\r\n     * @public\r\n     * @param doc - An object to be converted into a MongoDB modifier\r\n     * @param [options] Options\r\n     * @returns A MongoDB modifier.\r\n     *\r\n     * Converts an object into a modifier by flattening it, putting keys with\r\n     * null, undefined, and empty string values into `modifier.$unset`, and\r\n     * putting the rest of the keys into `modifier.$set`.\r\n     */\r\n    static docToModifier(doc, { keepArrays = false, keepEmptyStrings = false } = {}) {\r\n        // Flatten doc\r\n        const mDoc = new MongoObject(doc);\r\n        let flatDoc = mDoc.getFlatObject({ keepArrays });\r\n        // Get a list of null, undefined, and empty string values so we can unset them instead\r\n        const nulls = reportNulls(flatDoc, keepEmptyStrings);\r\n        flatDoc = cleanNulls(flatDoc, false, keepEmptyStrings);\r\n        const modifier = {};\r\n        if (!isEmpty(flatDoc))\r\n            modifier.$set = flatDoc;\r\n        if (!isEmpty(nulls))\r\n            modifier.$unset = nulls;\r\n        return modifier;\r\n    }\r\n    static objAffectsKey(obj, key) {\r\n        const mDoc = new MongoObject(obj);\r\n        return mDoc.affectsKey(key);\r\n    }\r\n    /**\r\n     * @param genericKey Generic key\r\n     * @return Array of other generic keys that would be created by this generic key\r\n     */\r\n    static objectsThatGenericKeyWillCreate(genericKey) {\r\n        const objs = [];\r\n        do {\r\n            const lastDotPosition = genericKey.lastIndexOf('.');\r\n            genericKey = lastDotPosition === -1 ? '' : genericKey.slice(0, lastDotPosition);\r\n            if (genericKey.length && !genericKey.endsWith('.$'))\r\n                objs.push(genericKey);\r\n        } while (genericKey.length);\r\n        return objs;\r\n    }\r\n    /**\r\n     * Takes a flat object and returns an expanded version of it.\r\n     */\r\n    static expandObj(doc) {\r\n        const newDoc = {};\r\n        Object.keys(doc).forEach((key) => {\r\n            const val = doc[key];\r\n            const subkeys = key.split('.');\r\n            const subkeylen = subkeys.length;\r\n            let current = newDoc;\r\n            for (let i = 0; i < subkeylen; i++) {\r\n                const subkey = subkeys[i];\r\n                if (typeof current[subkey] !== 'undefined'\r\n                    && !isObject(current[subkey])) {\r\n                    break; // Already set for some reason; leave it alone\r\n                }\r\n                if (i === subkeylen - 1) {\r\n                    // Last iteration; time to set the value\r\n                    current[subkey] = val;\r\n                }\r\n                else {\r\n                    // See if the next piece is a number\r\n                    const nextPiece = subkeys[i + 1];\r\n                    const nextPieceInt = parseInt(nextPiece, 10);\r\n                    if (Number.isNaN(nextPieceInt) && !isObject(current[subkey])) {\r\n                        current[subkey] = {};\r\n                    }\r\n                    else if (!Number.isNaN(nextPieceInt)\r\n                        && !Array.isArray(current[subkey])) {\r\n                        current[subkey] = [];\r\n                    }\r\n                }\r\n                current = current[subkey];\r\n            }\r\n        });\r\n        return newDoc;\r\n    }\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"util.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/mongo-object/dist/util.js                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({cleanNulls:()=>cleanNulls,isBasicObject:()=>isBasicObject,reportNulls:()=>reportNulls,appendAffectedKey:()=>appendAffectedKey,extractOp:()=>extractOp,genericKeyAffectsOtherGenericKey:()=>genericKeyAffectsOtherGenericKey,isNullUndefinedOrEmptyString:()=>isNullUndefinedOrEmptyString,isLength:()=>isLength,isArrayLike:()=>isArrayLike,each:()=>each,isPrototype:()=>isPrototype,isEmpty:()=>isEmpty,isObject:()=>isObject,makeKeyGeneric:()=>makeKeyGeneric,keyToPosition:()=>keyToPosition,expandKey:()=>expandKey});/** Used as references for various `Number` constants. */\r\nconst MAX_SAFE_INTEGER = 9007199254740991;\r\n/**\r\n * @param doc Source object or array\r\n * @param isArray True if `doc` is an array\r\n * @param keepEmptyStrings Whether to keep empty strings\r\n * @returns An object in which all properties with null, undefined, or empty\r\n *   string values have been removed, recursively.\r\n */\r\nfunction cleanNulls(doc, isArray = false, keepEmptyStrings = false) {\r\n    const newDoc = isArray ? [] : {};\r\n    Object.keys(doc).forEach((key) => {\r\n        let val = doc[key];\r\n        if (!Array.isArray(val) && isBasicObject(val)) {\r\n            val = cleanNulls(val, false, keepEmptyStrings); // Recurse into plain objects\r\n            if (!isEmpty(val))\r\n                newDoc[key] = val;\r\n        }\r\n        else if (Array.isArray(val)) {\r\n            val = cleanNulls(val, true, keepEmptyStrings); // Recurse into non-typed arrays\r\n            if (!isEmpty(val))\r\n                newDoc[key] = val;\r\n        }\r\n        else if (!isNullUndefinedOrEmptyString(val)) {\r\n            newDoc[key] = val;\r\n        }\r\n        else if (keepEmptyStrings\r\n            && typeof val === 'string'\r\n            && val.length === 0) {\r\n            newDoc[key] = val;\r\n        }\r\n    });\r\n    return newDoc;\r\n}\r\n/**\r\n * @param obj Any reference to check\r\n * @returns True if obj is an Object as opposed to\r\n *   something that inherits from Object\r\n */\r\nfunction isBasicObject(obj) {\r\n    return obj === Object(obj) && Object.getPrototypeOf(obj) === Object.prototype;\r\n}\r\n/**\r\n * @method MongoObject.reportNulls\r\n * @public\r\n * @param flatDoc An object with no properties that are also objects.\r\n * @returns An object in which the keys represent the keys in the\r\n *   original object that were null, undefined, or empty strings, and the value\r\n *   of each key is \"\".\r\n */\r\nfunction reportNulls(flatDoc, keepEmptyStrings = false) {\r\n    const nulls = {};\r\n    // Loop through the flat doc\r\n    Object.keys(flatDoc).forEach((key) => {\r\n        const val = flatDoc[key];\r\n        if (val === null\r\n            || val === undefined\r\n            || (!keepEmptyStrings && typeof val === 'string' && val.length === 0)\r\n            // If value is an array in which all the values recursively are undefined, null,\r\n            // or an empty string\r\n            || (Array.isArray(val)\r\n                && cleanNulls(val, true, keepEmptyStrings).length === 0)) {\r\n            nulls[key] = '';\r\n        }\r\n    });\r\n    return nulls;\r\n}\r\nfunction appendAffectedKey(affectedKey, key) {\r\n    if (key === '$each')\r\n        return affectedKey;\r\n    return affectedKey ? `${affectedKey}.${key}` : key;\r\n}\r\n// Extracts operator piece, if present, from position string\r\nfunction extractOp(position) {\r\n    const firstPositionPiece = position.slice(0, position.indexOf('['));\r\n    return firstPositionPiece.substring(0, 1) === '$' ? firstPositionPiece : null;\r\n}\r\nfunction genericKeyAffectsOtherGenericKey(key, affectedKey) {\r\n    // If the affected key is the test key\r\n    if (affectedKey === key)\r\n        return true;\r\n    // If the affected key implies the test key because the affected key\r\n    // starts with the test key followed by a period\r\n    if (affectedKey.substring(0, key.length + 1) === `${key}.`)\r\n        return true;\r\n    // If the affected key implies the test key because the affected key\r\n    // starts with the test key and the test key ends with \".$\"\r\n    const lastTwo = key.slice(-2);\r\n    if (lastTwo === '.$' && key.slice(0, -2) === affectedKey)\r\n        return true;\r\n    return false;\r\n}\r\nfunction isNullUndefinedOrEmptyString(val) {\r\n    return (val === undefined\r\n        || val === null\r\n        || (typeof val === 'string' && val.length === 0));\r\n}\r\nfunction isLength(value) {\r\n    return (typeof value === 'number'\r\n        && value > -1\r\n        && value % 1 === 0\r\n        && value <= MAX_SAFE_INTEGER);\r\n}\r\nfunction isArrayLike(value) {\r\n    return value != null && typeof value !== 'function' && isLength(value.length);\r\n}\r\nfunction each(collection, iteratee) {\r\n    if (collection == null) {\r\n        return;\r\n    }\r\n    if (Array.isArray(collection)) {\r\n        collection.forEach(iteratee);\r\n        return;\r\n    }\r\n    const iterable = Object(collection);\r\n    if (!isArrayLike(collection)) {\r\n        Object.keys(iterable).forEach((key) => iteratee(iterable[key], key, iterable));\r\n        return;\r\n    }\r\n    let index = -1;\r\n    while (++index < collection.length) {\r\n        if (iteratee(iterable[index], index, iterable) === false) {\r\n            break;\r\n        }\r\n    }\r\n}\r\nfunction isPrototype(value) {\r\n    const Ctor = value && value.constructor;\r\n    const proto = (typeof Ctor === 'function' && Ctor.prototype) || Object.prototype;\r\n    return value === proto;\r\n}\r\nfunction isEmpty(value) {\r\n    if (value === null || value === undefined) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(value) || typeof value === 'string') {\r\n        return !value.length;\r\n    }\r\n    const tag = Object.prototype.toString.call(value);\r\n    if (tag === '[object Map]' || tag === '[object Set]') {\r\n        return !value.size;\r\n    }\r\n    if (isPrototype(value)) {\r\n        return !Object.keys(value).length;\r\n    }\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    for (const key in value) {\r\n        if (Object.hasOwnProperty.call(value, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isObject(value) {\r\n    const type = typeof value;\r\n    return value != null && (type === 'object' || type === 'function');\r\n}\r\n/* Takes a specific string that uses any mongo-style positional update\r\n * dot notation and returns a generic string equivalent. Replaces all numeric\r\n * positional \"pieces\" (e.g. '.1') or any other positional operator\r\n * (e.g. '$[<identifier>]')  with a dollar sign ($).\r\n *\r\n * @param key A specific or generic key\r\n * @returns Generic name.\r\n */\r\nfunction makeKeyGeneric(key) {\r\n    if (typeof key !== 'string')\r\n        return null;\r\n    return key.replace(/\\.([0-9]+|\\$\\[[^\\]]*\\])(?=\\.|$)/g, '.$');\r\n}\r\nfunction keyToPosition(key, wrapAll = false) {\r\n    let position = '';\r\n    key.split('.').forEach((piece, i) => {\r\n        if (i === 0 && !wrapAll) {\r\n            position += piece;\r\n        }\r\n        else {\r\n            position += `[${piece}]`;\r\n        }\r\n    });\r\n    return position;\r\n}\r\n/**\r\n *  Takes a string representation of an object key and its value\r\n *  and updates \"obj\" to contain that key with that value.\r\n *\r\n *  Example keys and results if val is 1:\r\n *    \"a\" -> {a: 1}\r\n *    \"a[b]\" -> {a: {b: 1}}\r\n *    \"a[b][0]\" -> {a: {b: [1]}}\r\n *    'a[b.0.c]' -> {a: {'b.0.c': 1}}\r\n * @param val Value\r\n * @param key Key\r\n * @param obj Object\r\n */\r\nfunction expandKey(val, key, obj) {\r\n    const subkeys = key.split('[');\r\n    let current = obj;\r\n    for (let i = 0, ln = subkeys.length; i < ln; i++) {\r\n        let subkey = subkeys[i];\r\n        if (subkey.slice(-1) === ']') {\r\n            subkey = subkey.slice(0, -1);\r\n        }\r\n        if (i === ln - 1) {\r\n            // Last iteration; time to set the value; always overwrite\r\n            current[subkey] = val;\r\n            // If val is undefined, delete the property\r\n            if (val === undefined)\r\n                delete current[subkey];\r\n        }\r\n        else {\r\n            // See if the next piece is a number\r\n            const nextPiece = subkeys[i + 1];\r\n            if (!current[subkey]) {\r\n                current[subkey] = Number.isNaN(parseInt(nextPiece, 10)) ? {} : [];\r\n            }\r\n        }\r\n        current = current[subkey];\r\n    }\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"react\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/react/package.json                                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"browserify\": {\n    \"transform\": [\n      \"loose-envify\"\n    ]\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/facebook/react/issues\"\n  },\n  \"dependencies\": {\n    \"loose-envify\": \"^1.1.0\"\n  },\n  \"description\": \"React is a JavaScript library for building user interfaces.\",\n  \"engines\": {\n    \"node\": \">=0.10.0\"\n  },\n  \"exports\": {\n    \".\": {\n      \"react-server\": \"./react.shared-subset.js\",\n      \"default\": \"./index.js\"\n    },\n    \"./package.json\": \"./package.json\",\n    \"./jsx-runtime\": \"./jsx-runtime.js\",\n    \"./jsx-dev-runtime\": \"./jsx-dev-runtime.js\"\n  },\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"index.js\",\n    \"cjs/\",\n    \"umd/\",\n    \"jsx-runtime.js\",\n    \"jsx-dev-runtime.js\",\n    \"react.shared-subset.js\"\n  ],\n  \"homepage\": \"https://reactjs.org/\",\n  \"keywords\": [\n    \"react\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"index.js\",\n  \"name\": \"react\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/facebook/react.git\",\n    \"directory\": \"packages/react\"\n  },\n  \"version\": \"18.2.0\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"@babel\":{\"runtime\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/@babel/runtime/package.json                                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"author\": {\n    \"name\": \"The Babel Team\",\n    \"url\": \"https://babel.dev/team\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/babel/babel/issues\"\n  },\n  \"dependencies\": {\n    \"regenerator-runtime\": \"^0.13.4\"\n  },\n  \"description\": \"babel's modular runtime helpers\",\n  \"engines\": {\n    \"node\": \">=6.9.0\"\n  },\n  \"exports\": {\n    \"./helpers/AsyncGenerator\": [\n      {\n        \"node\": \"./helpers/AsyncGenerator.js\",\n        \"import\": \"./helpers/esm/AsyncGenerator.js\",\n        \"default\": \"./helpers/AsyncGenerator.js\"\n      },\n      \"./helpers/AsyncGenerator.js\"\n    ],\n    \"./helpers/esm/AsyncGenerator\": \"./helpers/esm/AsyncGenerator.js\",\n    \"./helpers/OverloadYield\": [\n      {\n        \"node\": \"./helpers/OverloadYield.js\",\n        \"import\": \"./helpers/esm/OverloadYield.js\",\n        \"default\": \"./helpers/OverloadYield.js\"\n      },\n      \"./helpers/OverloadYield.js\"\n    ],\n    \"./helpers/esm/OverloadYield\": \"./helpers/esm/OverloadYield.js\",\n    \"./helpers/applyDecs\": [\n      {\n        \"node\": \"./helpers/applyDecs.js\",\n        \"import\": \"./helpers/esm/applyDecs.js\",\n        \"default\": \"./helpers/applyDecs.js\"\n      },\n      \"./helpers/applyDecs.js\"\n    ],\n    \"./helpers/esm/applyDecs\": \"./helpers/esm/applyDecs.js\",\n    \"./helpers/applyDecs2203\": [\n      {\n        \"node\": \"./helpers/applyDecs2203.js\",\n        \"import\": \"./helpers/esm/applyDecs2203.js\",\n        \"default\": \"./helpers/applyDecs2203.js\"\n      },\n      \"./helpers/applyDecs2203.js\"\n    ],\n    \"./helpers/esm/applyDecs2203\": \"./helpers/esm/applyDecs2203.js\",\n    \"./helpers/asyncGeneratorDelegate\": [\n      {\n        \"node\": \"./helpers/asyncGeneratorDelegate.js\",\n        \"import\": \"./helpers/esm/asyncGeneratorDelegate.js\",\n        \"default\": \"./helpers/asyncGeneratorDelegate.js\"\n      },\n      \"./helpers/asyncGeneratorDelegate.js\"\n    ],\n    \"./helpers/esm/asyncGeneratorDelegate\": \"./helpers/esm/asyncGeneratorDelegate.js\",\n    \"./helpers/asyncIterator\": [\n      {\n        \"node\": \"./helpers/asyncIterator.js\",\n        \"import\": \"./helpers/esm/asyncIterator.js\",\n        \"default\": \"./helpers/asyncIterator.js\"\n      },\n      \"./helpers/asyncIterator.js\"\n    ],\n    \"./helpers/esm/asyncIterator\": \"./helpers/esm/asyncIterator.js\",\n    \"./helpers/awaitAsyncGenerator\": [\n      {\n        \"node\": \"./helpers/awaitAsyncGenerator.js\",\n        \"import\": \"./helpers/esm/awaitAsyncGenerator.js\",\n        \"default\": \"./helpers/awaitAsyncGenerator.js\"\n      },\n      \"./helpers/awaitAsyncGenerator.js\"\n    ],\n    \"./helpers/esm/awaitAsyncGenerator\": \"./helpers/esm/awaitAsyncGenerator.js\",\n    \"./helpers/jsx\": [\n      {\n        \"node\": \"./helpers/jsx.js\",\n        \"import\": \"./helpers/esm/jsx.js\",\n        \"default\": \"./helpers/jsx.js\"\n      },\n      \"./helpers/jsx.js\"\n    ],\n    \"./helpers/esm/jsx\": \"./helpers/esm/jsx.js\",\n    \"./helpers/objectSpread2\": [\n      {\n        \"node\": \"./helpers/objectSpread2.js\",\n        \"import\": \"./helpers/esm/objectSpread2.js\",\n        \"default\": \"./helpers/objectSpread2.js\"\n      },\n      \"./helpers/objectSpread2.js\"\n    ],\n    \"./helpers/esm/objectSpread2\": \"./helpers/esm/objectSpread2.js\",\n    \"./helpers/regeneratorRuntime\": [\n      {\n        \"node\": \"./helpers/regeneratorRuntime.js\",\n        \"import\": \"./helpers/esm/regeneratorRuntime.js\",\n        \"default\": \"./helpers/regeneratorRuntime.js\"\n      },\n      \"./helpers/regeneratorRuntime.js\"\n    ],\n    \"./helpers/esm/regeneratorRuntime\": \"./helpers/esm/regeneratorRuntime.js\",\n    \"./helpers/typeof\": [\n      {\n        \"node\": \"./helpers/typeof.js\",\n        \"import\": \"./helpers/esm/typeof.js\",\n        \"default\": \"./helpers/typeof.js\"\n      },\n      \"./helpers/typeof.js\"\n    ],\n    \"./helpers/esm/typeof\": \"./helpers/esm/typeof.js\",\n    \"./helpers/wrapRegExp\": [\n      {\n        \"node\": \"./helpers/wrapRegExp.js\",\n        \"import\": \"./helpers/esm/wrapRegExp.js\",\n        \"default\": \"./helpers/wrapRegExp.js\"\n      },\n      \"./helpers/wrapRegExp.js\"\n    ],\n    \"./helpers/esm/wrapRegExp\": \"./helpers/esm/wrapRegExp.js\",\n    \"./helpers/AwaitValue\": [\n      {\n        \"node\": \"./helpers/AwaitValue.js\",\n        \"import\": \"./helpers/esm/AwaitValue.js\",\n        \"default\": \"./helpers/AwaitValue.js\"\n      },\n      \"./helpers/AwaitValue.js\"\n    ],\n    \"./helpers/esm/AwaitValue\": \"./helpers/esm/AwaitValue.js\",\n    \"./helpers/wrapAsyncGenerator\": [\n      {\n        \"node\": \"./helpers/wrapAsyncGenerator.js\",\n        \"import\": \"./helpers/esm/wrapAsyncGenerator.js\",\n        \"default\": \"./helpers/wrapAsyncGenerator.js\"\n      },\n      \"./helpers/wrapAsyncGenerator.js\"\n    ],\n    \"./helpers/esm/wrapAsyncGenerator\": \"./helpers/esm/wrapAsyncGenerator.js\",\n    \"./helpers/asyncToGenerator\": [\n      {\n        \"node\": \"./helpers/asyncToGenerator.js\",\n        \"import\": \"./helpers/esm/asyncToGenerator.js\",\n        \"default\": \"./helpers/asyncToGenerator.js\"\n      },\n      \"./helpers/asyncToGenerator.js\"\n    ],\n    \"./helpers/esm/asyncToGenerator\": \"./helpers/esm/asyncToGenerator.js\",\n    \"./helpers/classCallCheck\": [\n      {\n        \"node\": \"./helpers/classCallCheck.js\",\n        \"import\": \"./helpers/esm/classCallCheck.js\",\n        \"default\": \"./helpers/classCallCheck.js\"\n      },\n      \"./helpers/classCallCheck.js\"\n    ],\n    \"./helpers/esm/classCallCheck\": \"./helpers/esm/classCallCheck.js\",\n    \"./helpers/createClass\": [\n      {\n        \"node\": \"./helpers/createClass.js\",\n        \"import\": \"./helpers/esm/createClass.js\",\n        \"default\": \"./helpers/createClass.js\"\n      },\n      \"./helpers/createClass.js\"\n    ],\n    \"./helpers/esm/createClass\": \"./helpers/esm/createClass.js\",\n    \"./helpers/defineEnumerableProperties\": [\n      {\n        \"node\": \"./helpers/defineEnumerableProperties.js\",\n        \"import\": \"./helpers/esm/defineEnumerableProperties.js\",\n        \"default\": \"./helpers/defineEnumerableProperties.js\"\n      },\n      \"./helpers/defineEnumerableProperties.js\"\n    ],\n    \"./helpers/esm/defineEnumerableProperties\": \"./helpers/esm/defineEnumerableProperties.js\",\n    \"./helpers/defaults\": [\n      {\n        \"node\": \"./helpers/defaults.js\",\n        \"import\": \"./helpers/esm/defaults.js\",\n        \"default\": \"./helpers/defaults.js\"\n      },\n      \"./helpers/defaults.js\"\n    ],\n    \"./helpers/esm/defaults\": \"./helpers/esm/defaults.js\",\n    \"./helpers/defineProperty\": [\n      {\n        \"node\": \"./helpers/defineProperty.js\",\n        \"import\": \"./helpers/esm/defineProperty.js\",\n        \"default\": \"./helpers/defineProperty.js\"\n      },\n      \"./helpers/defineProperty.js\"\n    ],\n    \"./helpers/esm/defineProperty\": \"./helpers/esm/defineProperty.js\",\n    \"./helpers/extends\": [\n      {\n        \"node\": \"./helpers/extends.js\",\n        \"import\": \"./helpers/esm/extends.js\",\n        \"default\": \"./helpers/extends.js\"\n      },\n      \"./helpers/extends.js\"\n    ],\n    \"./helpers/esm/extends\": \"./helpers/esm/extends.js\",\n    \"./helpers/objectSpread\": [\n      {\n        \"node\": \"./helpers/objectSpread.js\",\n        \"import\": \"./helpers/esm/objectSpread.js\",\n        \"default\": \"./helpers/objectSpread.js\"\n      },\n      \"./helpers/objectSpread.js\"\n    ],\n    \"./helpers/esm/objectSpread\": \"./helpers/esm/objectSpread.js\",\n    \"./helpers/inherits\": [\n      {\n        \"node\": \"./helpers/inherits.js\",\n        \"import\": \"./helpers/esm/inherits.js\",\n        \"default\": \"./helpers/inherits.js\"\n      },\n      \"./helpers/inherits.js\"\n    ],\n    \"./helpers/esm/inherits\": \"./helpers/esm/inherits.js\",\n    \"./helpers/inheritsLoose\": [\n      {\n        \"node\": \"./helpers/inheritsLoose.js\",\n        \"import\": \"./helpers/esm/inheritsLoose.js\",\n        \"default\": \"./helpers/inheritsLoose.js\"\n      },\n      \"./helpers/inheritsLoose.js\"\n    ],\n    \"./helpers/esm/inheritsLoose\": \"./helpers/esm/inheritsLoose.js\",\n    \"./helpers/getPrototypeOf\": [\n      {\n        \"node\": \"./helpers/getPrototypeOf.js\",\n        \"import\": \"./helpers/esm/getPrototypeOf.js\",\n        \"default\": \"./helpers/getPrototypeOf.js\"\n      },\n      \"./helpers/getPrototypeOf.js\"\n    ],\n    \"./helpers/esm/getPrototypeOf\": \"./helpers/esm/getPrototypeOf.js\",\n    \"./helpers/setPrototypeOf\": [\n      {\n        \"node\": \"./helpers/setPrototypeOf.js\",\n        \"import\": \"./helpers/esm/setPrototypeOf.js\",\n        \"default\": \"./helpers/setPrototypeOf.js\"\n      },\n      \"./helpers/setPrototypeOf.js\"\n    ],\n    \"./helpers/esm/setPrototypeOf\": \"./helpers/esm/setPrototypeOf.js\",\n    \"./helpers/isNativeReflectConstruct\": [\n      {\n        \"node\": \"./helpers/isNativeReflectConstruct.js\",\n        \"import\": \"./helpers/esm/isNativeReflectConstruct.js\",\n        \"default\": \"./helpers/isNativeReflectConstruct.js\"\n      },\n      \"./helpers/isNativeReflectConstruct.js\"\n    ],\n    \"./helpers/esm/isNativeReflectConstruct\": \"./helpers/esm/isNativeReflectConstruct.js\",\n    \"./helpers/construct\": [\n      {\n        \"node\": \"./helpers/construct.js\",\n        \"import\": \"./helpers/esm/construct.js\",\n        \"default\": \"./helpers/construct.js\"\n      },\n      \"./helpers/construct.js\"\n    ],\n    \"./helpers/esm/construct\": \"./helpers/esm/construct.js\",\n    \"./helpers/isNativeFunction\": [\n      {\n        \"node\": \"./helpers/isNativeFunction.js\",\n        \"import\": \"./helpers/esm/isNativeFunction.js\",\n        \"default\": \"./helpers/isNativeFunction.js\"\n      },\n      \"./helpers/isNativeFunction.js\"\n    ],\n    \"./helpers/esm/isNativeFunction\": \"./helpers/esm/isNativeFunction.js\",\n    \"./helpers/wrapNativeSuper\": [\n      {\n        \"node\": \"./helpers/wrapNativeSuper.js\",\n        \"import\": \"./helpers/esm/wrapNativeSuper.js\",\n        \"default\": \"./helpers/wrapNativeSuper.js\"\n      },\n      \"./helpers/wrapNativeSuper.js\"\n    ],\n    \"./helpers/esm/wrapNativeSuper\": \"./helpers/esm/wrapNativeSuper.js\",\n    \"./helpers/instanceof\": [\n      {\n        \"node\": \"./helpers/instanceof.js\",\n        \"import\": \"./helpers/esm/instanceof.js\",\n        \"default\": \"./helpers/instanceof.js\"\n      },\n      \"./helpers/instanceof.js\"\n    ],\n    \"./helpers/esm/instanceof\": \"./helpers/esm/instanceof.js\",\n    \"./helpers/interopRequireDefault\": [\n      {\n        \"node\": \"./helpers/interopRequireDefault.js\",\n        \"import\": \"./helpers/esm/interopRequireDefault.js\",\n        \"default\": \"./helpers/interopRequireDefault.js\"\n      },\n      \"./helpers/interopRequireDefault.js\"\n    ],\n    \"./helpers/esm/interopRequireDefault\": \"./helpers/esm/interopRequireDefault.js\",\n    \"./helpers/interopRequireWildcard\": [\n      {\n        \"node\": \"./helpers/interopRequireWildcard.js\",\n        \"import\": \"./helpers/esm/interopRequireWildcard.js\",\n        \"default\": \"./helpers/interopRequireWildcard.js\"\n      },\n      \"./helpers/interopRequireWildcard.js\"\n    ],\n    \"./helpers/esm/interopRequireWildcard\": \"./helpers/esm/interopRequireWildcard.js\",\n    \"./helpers/newArrowCheck\": [\n      {\n        \"node\": \"./helpers/newArrowCheck.js\",\n        \"import\": \"./helpers/esm/newArrowCheck.js\",\n        \"default\": \"./helpers/newArrowCheck.js\"\n      },\n      \"./helpers/newArrowCheck.js\"\n    ],\n    \"./helpers/esm/newArrowCheck\": \"./helpers/esm/newArrowCheck.js\",\n    \"./helpers/objectDestructuringEmpty\": [\n      {\n        \"node\": \"./helpers/objectDestructuringEmpty.js\",\n        \"import\": \"./helpers/esm/objectDestructuringEmpty.js\",\n        \"default\": \"./helpers/objectDestructuringEmpty.js\"\n      },\n      \"./helpers/objectDestructuringEmpty.js\"\n    ],\n    \"./helpers/esm/objectDestructuringEmpty\": \"./helpers/esm/objectDestructuringEmpty.js\",\n    \"./helpers/objectWithoutPropertiesLoose\": [\n      {\n        \"node\": \"./helpers/objectWithoutPropertiesLoose.js\",\n        \"import\": \"./helpers/esm/objectWithoutPropertiesLoose.js\",\n        \"default\": \"./helpers/objectWithoutPropertiesLoose.js\"\n      },\n      \"./helpers/objectWithoutPropertiesLoose.js\"\n    ],\n    \"./helpers/esm/objectWithoutPropertiesLoose\": \"./helpers/esm/objectWithoutPropertiesLoose.js\",\n    \"./helpers/objectWithoutProperties\": [\n      {\n        \"node\": \"./helpers/objectWithoutProperties.js\",\n        \"import\": \"./helpers/esm/objectWithoutProperties.js\",\n        \"default\": \"./helpers/objectWithoutProperties.js\"\n      },\n      \"./helpers/objectWithoutProperties.js\"\n    ],\n    \"./helpers/esm/objectWithoutProperties\": \"./helpers/esm/objectWithoutProperties.js\",\n    \"./helpers/assertThisInitialized\": [\n      {\n        \"node\": \"./helpers/assertThisInitialized.js\",\n        \"import\": \"./helpers/esm/assertThisInitialized.js\",\n        \"default\": \"./helpers/assertThisInitialized.js\"\n      },\n      \"./helpers/assertThisInitialized.js\"\n    ],\n    \"./helpers/esm/assertThisInitialized\": \"./helpers/esm/assertThisInitialized.js\",\n    \"./helpers/possibleConstructorReturn\": [\n      {\n        \"node\": \"./helpers/possibleConstructorReturn.js\",\n        \"import\": \"./helpers/esm/possibleConstructorReturn.js\",\n        \"default\": \"./helpers/possibleConstructorReturn.js\"\n      },\n      \"./helpers/possibleConstructorReturn.js\"\n    ],\n    \"./helpers/esm/possibleConstructorReturn\": \"./helpers/esm/possibleConstructorReturn.js\",\n    \"./helpers/createSuper\": [\n      {\n        \"node\": \"./helpers/createSuper.js\",\n        \"import\": \"./helpers/esm/createSuper.js\",\n        \"default\": \"./helpers/createSuper.js\"\n      },\n      \"./helpers/createSuper.js\"\n    ],\n    \"./helpers/esm/createSuper\": \"./helpers/esm/createSuper.js\",\n    \"./helpers/superPropBase\": [\n      {\n        \"node\": \"./helpers/superPropBase.js\",\n        \"import\": \"./helpers/esm/superPropBase.js\",\n        \"default\": \"./helpers/superPropBase.js\"\n      },\n      \"./helpers/superPropBase.js\"\n    ],\n    \"./helpers/esm/superPropBase\": \"./helpers/esm/superPropBase.js\",\n    \"./helpers/get\": [\n      {\n        \"node\": \"./helpers/get.js\",\n        \"import\": \"./helpers/esm/get.js\",\n        \"default\": \"./helpers/get.js\"\n      },\n      \"./helpers/get.js\"\n    ],\n    \"./helpers/esm/get\": \"./helpers/esm/get.js\",\n    \"./helpers/set\": [\n      {\n        \"node\": \"./helpers/set.js\",\n        \"import\": \"./helpers/esm/set.js\",\n        \"default\": \"./helpers/set.js\"\n      },\n      \"./helpers/set.js\"\n    ],\n    \"./helpers/esm/set\": \"./helpers/esm/set.js\",\n    \"./helpers/taggedTemplateLiteral\": [\n      {\n        \"node\": \"./helpers/taggedTemplateLiteral.js\",\n        \"import\": \"./helpers/esm/taggedTemplateLiteral.js\",\n        \"default\": \"./helpers/taggedTemplateLiteral.js\"\n      },\n      \"./helpers/taggedTemplateLiteral.js\"\n    ],\n    \"./helpers/esm/taggedTemplateLiteral\": \"./helpers/esm/taggedTemplateLiteral.js\",\n    \"./helpers/taggedTemplateLiteralLoose\": [\n      {\n        \"node\": \"./helpers/taggedTemplateLiteralLoose.js\",\n        \"import\": \"./helpers/esm/taggedTemplateLiteralLoose.js\",\n        \"default\": \"./helpers/taggedTemplateLiteralLoose.js\"\n      },\n      \"./helpers/taggedTemplateLiteralLoose.js\"\n    ],\n    \"./helpers/esm/taggedTemplateLiteralLoose\": \"./helpers/esm/taggedTemplateLiteralLoose.js\",\n    \"./helpers/readOnlyError\": [\n      {\n        \"node\": \"./helpers/readOnlyError.js\",\n        \"import\": \"./helpers/esm/readOnlyError.js\",\n        \"default\": \"./helpers/readOnlyError.js\"\n      },\n      \"./helpers/readOnlyError.js\"\n    ],\n    \"./helpers/esm/readOnlyError\": \"./helpers/esm/readOnlyError.js\",\n    \"./helpers/writeOnlyError\": [\n      {\n        \"node\": \"./helpers/writeOnlyError.js\",\n        \"import\": \"./helpers/esm/writeOnlyError.js\",\n        \"default\": \"./helpers/writeOnlyError.js\"\n      },\n      \"./helpers/writeOnlyError.js\"\n    ],\n    \"./helpers/esm/writeOnlyError\": \"./helpers/esm/writeOnlyError.js\",\n    \"./helpers/classNameTDZError\": [\n      {\n        \"node\": \"./helpers/classNameTDZError.js\",\n        \"import\": \"./helpers/esm/classNameTDZError.js\",\n        \"default\": \"./helpers/classNameTDZError.js\"\n      },\n      \"./helpers/classNameTDZError.js\"\n    ],\n    \"./helpers/esm/classNameTDZError\": \"./helpers/esm/classNameTDZError.js\",\n    \"./helpers/temporalUndefined\": [\n      {\n        \"node\": \"./helpers/temporalUndefined.js\",\n        \"import\": \"./helpers/esm/temporalUndefined.js\",\n        \"default\": \"./helpers/temporalUndefined.js\"\n      },\n      \"./helpers/temporalUndefined.js\"\n    ],\n    \"./helpers/esm/temporalUndefined\": \"./helpers/esm/temporalUndefined.js\",\n    \"./helpers/tdz\": [\n      {\n        \"node\": \"./helpers/tdz.js\",\n        \"import\": \"./helpers/esm/tdz.js\",\n        \"default\": \"./helpers/tdz.js\"\n      },\n      \"./helpers/tdz.js\"\n    ],\n    \"./helpers/esm/tdz\": \"./helpers/esm/tdz.js\",\n    \"./helpers/temporalRef\": [\n      {\n        \"node\": \"./helpers/temporalRef.js\",\n        \"import\": \"./helpers/esm/temporalRef.js\",\n        \"default\": \"./helpers/temporalRef.js\"\n      },\n      \"./helpers/temporalRef.js\"\n    ],\n    \"./helpers/esm/temporalRef\": \"./helpers/esm/temporalRef.js\",\n    \"./helpers/slicedToArray\": [\n      {\n        \"node\": \"./helpers/slicedToArray.js\",\n        \"import\": \"./helpers/esm/slicedToArray.js\",\n        \"default\": \"./helpers/slicedToArray.js\"\n      },\n      \"./helpers/slicedToArray.js\"\n    ],\n    \"./helpers/esm/slicedToArray\": \"./helpers/esm/slicedToArray.js\",\n    \"./helpers/slicedToArrayLoose\": [\n      {\n        \"node\": \"./helpers/slicedToArrayLoose.js\",\n        \"import\": \"./helpers/esm/slicedToArrayLoose.js\",\n        \"default\": \"./helpers/slicedToArrayLoose.js\"\n      },\n      \"./helpers/slicedToArrayLoose.js\"\n    ],\n    \"./helpers/esm/slicedToArrayLoose\": \"./helpers/esm/slicedToArrayLoose.js\",\n    \"./helpers/toArray\": [\n      {\n        \"node\": \"./helpers/toArray.js\",\n        \"import\": \"./helpers/esm/toArray.js\",\n        \"default\": \"./helpers/toArray.js\"\n      },\n      \"./helpers/toArray.js\"\n    ],\n    \"./helpers/esm/toArray\": \"./helpers/esm/toArray.js\",\n    \"./helpers/toConsumableArray\": [\n      {\n        \"node\": \"./helpers/toConsumableArray.js\",\n        \"import\": \"./helpers/esm/toConsumableArray.js\",\n        \"default\": \"./helpers/toConsumableArray.js\"\n      },\n      \"./helpers/toConsumableArray.js\"\n    ],\n    \"./helpers/esm/toConsumableArray\": \"./helpers/esm/toConsumableArray.js\",\n    \"./helpers/arrayWithoutHoles\": [\n      {\n        \"node\": \"./helpers/arrayWithoutHoles.js\",\n        \"import\": \"./helpers/esm/arrayWithoutHoles.js\",\n        \"default\": \"./helpers/arrayWithoutHoles.js\"\n      },\n      \"./helpers/arrayWithoutHoles.js\"\n    ],\n    \"./helpers/esm/arrayWithoutHoles\": \"./helpers/esm/arrayWithoutHoles.js\",\n    \"./helpers/arrayWithHoles\": [\n      {\n        \"node\": \"./helpers/arrayWithHoles.js\",\n        \"import\": \"./helpers/esm/arrayWithHoles.js\",\n        \"default\": \"./helpers/arrayWithHoles.js\"\n      },\n      \"./helpers/arrayWithHoles.js\"\n    ],\n    \"./helpers/esm/arrayWithHoles\": \"./helpers/esm/arrayWithHoles.js\",\n    \"./helpers/maybeArrayLike\": [\n      {\n        \"node\": \"./helpers/maybeArrayLike.js\",\n        \"import\": \"./helpers/esm/maybeArrayLike.js\",\n        \"default\": \"./helpers/maybeArrayLike.js\"\n      },\n      \"./helpers/maybeArrayLike.js\"\n    ],\n    \"./helpers/esm/maybeArrayLike\": \"./helpers/esm/maybeArrayLike.js\",\n    \"./helpers/iterableToArray\": [\n      {\n        \"node\": \"./helpers/iterableToArray.js\",\n        \"import\": \"./helpers/esm/iterableToArray.js\",\n        \"default\": \"./helpers/iterableToArray.js\"\n      },\n      \"./helpers/iterableToArray.js\"\n    ],\n    \"./helpers/esm/iterableToArray\": \"./helpers/esm/iterableToArray.js\",\n    \"./helpers/iterableToArrayLimit\": [\n      {\n        \"node\": \"./helpers/iterableToArrayLimit.js\",\n        \"import\": \"./helpers/esm/iterableToArrayLimit.js\",\n        \"default\": \"./helpers/iterableToArrayLimit.js\"\n      },\n      \"./helpers/iterableToArrayLimit.js\"\n    ],\n    \"./helpers/esm/iterableToArrayLimit\": \"./helpers/esm/iterableToArrayLimit.js\",\n    \"./helpers/iterableToArrayLimitLoose\": [\n      {\n        \"node\": \"./helpers/iterableToArrayLimitLoose.js\",\n        \"import\": \"./helpers/esm/iterableToArrayLimitLoose.js\",\n        \"default\": \"./helpers/iterableToArrayLimitLoose.js\"\n      },\n      \"./helpers/iterableToArrayLimitLoose.js\"\n    ],\n    \"./helpers/esm/iterableToArrayLimitLoose\": \"./helpers/esm/iterableToArrayLimitLoose.js\",\n    \"./helpers/unsupportedIterableToArray\": [\n      {\n        \"node\": \"./helpers/unsupportedIterableToArray.js\",\n        \"import\": \"./helpers/esm/unsupportedIterableToArray.js\",\n        \"default\": \"./helpers/unsupportedIterableToArray.js\"\n      },\n      \"./helpers/unsupportedIterableToArray.js\"\n    ],\n    \"./helpers/esm/unsupportedIterableToArray\": \"./helpers/esm/unsupportedIterableToArray.js\",\n    \"./helpers/arrayLikeToArray\": [\n      {\n        \"node\": \"./helpers/arrayLikeToArray.js\",\n        \"import\": \"./helpers/esm/arrayLikeToArray.js\",\n        \"default\": \"./helpers/arrayLikeToArray.js\"\n      },\n      \"./helpers/arrayLikeToArray.js\"\n    ],\n    \"./helpers/esm/arrayLikeToArray\": \"./helpers/esm/arrayLikeToArray.js\",\n    \"./helpers/nonIterableSpread\": [\n      {\n        \"node\": \"./helpers/nonIterableSpread.js\",\n        \"import\": \"./helpers/esm/nonIterableSpread.js\",\n        \"default\": \"./helpers/nonIterableSpread.js\"\n      },\n      \"./helpers/nonIterableSpread.js\"\n    ],\n    \"./helpers/esm/nonIterableSpread\": \"./helpers/esm/nonIterableSpread.js\",\n    \"./helpers/nonIterableRest\": [\n      {\n        \"node\": \"./helpers/nonIterableRest.js\",\n        \"import\": \"./helpers/esm/nonIterableRest.js\",\n        \"default\": \"./helpers/nonIterableRest.js\"\n      },\n      \"./helpers/nonIterableRest.js\"\n    ],\n    \"./helpers/esm/nonIterableRest\": \"./helpers/esm/nonIterableRest.js\",\n    \"./helpers/createForOfIteratorHelper\": [\n      {\n        \"node\": \"./helpers/createForOfIteratorHelper.js\",\n        \"import\": \"./helpers/esm/createForOfIteratorHelper.js\",\n        \"default\": \"./helpers/createForOfIteratorHelper.js\"\n      },\n      \"./helpers/createForOfIteratorHelper.js\"\n    ],\n    \"./helpers/esm/createForOfIteratorHelper\": \"./helpers/esm/createForOfIteratorHelper.js\",\n    \"./helpers/createForOfIteratorHelperLoose\": [\n      {\n        \"node\": \"./helpers/createForOfIteratorHelperLoose.js\",\n        \"import\": \"./helpers/esm/createForOfIteratorHelperLoose.js\",\n        \"default\": \"./helpers/createForOfIteratorHelperLoose.js\"\n      },\n      \"./helpers/createForOfIteratorHelperLoose.js\"\n    ],\n    \"./helpers/esm/createForOfIteratorHelperLoose\": \"./helpers/esm/createForOfIteratorHelperLoose.js\",\n    \"./helpers/skipFirstGeneratorNext\": [\n      {\n        \"node\": \"./helpers/skipFirstGeneratorNext.js\",\n        \"import\": \"./helpers/esm/skipFirstGeneratorNext.js\",\n        \"default\": \"./helpers/skipFirstGeneratorNext.js\"\n      },\n      \"./helpers/skipFirstGeneratorNext.js\"\n    ],\n    \"./helpers/esm/skipFirstGeneratorNext\": \"./helpers/esm/skipFirstGeneratorNext.js\",\n    \"./helpers/toPrimitive\": [\n      {\n        \"node\": \"./helpers/toPrimitive.js\",\n        \"import\": \"./helpers/esm/toPrimitive.js\",\n        \"default\": \"./helpers/toPrimitive.js\"\n      },\n      \"./helpers/toPrimitive.js\"\n    ],\n    \"./helpers/esm/toPrimitive\": \"./helpers/esm/toPrimitive.js\",\n    \"./helpers/toPropertyKey\": [\n      {\n        \"node\": \"./helpers/toPropertyKey.js\",\n        \"import\": \"./helpers/esm/toPropertyKey.js\",\n        \"default\": \"./helpers/toPropertyKey.js\"\n      },\n      \"./helpers/toPropertyKey.js\"\n    ],\n    \"./helpers/esm/toPropertyKey\": \"./helpers/esm/toPropertyKey.js\",\n    \"./helpers/initializerWarningHelper\": [\n      {\n        \"node\": \"./helpers/initializerWarningHelper.js\",\n        \"import\": \"./helpers/esm/initializerWarningHelper.js\",\n        \"default\": \"./helpers/initializerWarningHelper.js\"\n      },\n      \"./helpers/initializerWarningHelper.js\"\n    ],\n    \"./helpers/esm/initializerWarningHelper\": \"./helpers/esm/initializerWarningHelper.js\",\n    \"./helpers/initializerDefineProperty\": [\n      {\n        \"node\": \"./helpers/initializerDefineProperty.js\",\n        \"import\": \"./helpers/esm/initializerDefineProperty.js\",\n        \"default\": \"./helpers/initializerDefineProperty.js\"\n      },\n      \"./helpers/initializerDefineProperty.js\"\n    ],\n    \"./helpers/esm/initializerDefineProperty\": \"./helpers/esm/initializerDefineProperty.js\",\n    \"./helpers/applyDecoratedDescriptor\": [\n      {\n        \"node\": \"./helpers/applyDecoratedDescriptor.js\",\n        \"import\": \"./helpers/esm/applyDecoratedDescriptor.js\",\n        \"default\": \"./helpers/applyDecoratedDescriptor.js\"\n      },\n      \"./helpers/applyDecoratedDescriptor.js\"\n    ],\n    \"./helpers/esm/applyDecoratedDescriptor\": \"./helpers/esm/applyDecoratedDescriptor.js\",\n    \"./helpers/classPrivateFieldLooseKey\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldLooseKey.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldLooseKey.js\",\n        \"default\": \"./helpers/classPrivateFieldLooseKey.js\"\n      },\n      \"./helpers/classPrivateFieldLooseKey.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldLooseKey\": \"./helpers/esm/classPrivateFieldLooseKey.js\",\n    \"./helpers/classPrivateFieldLooseBase\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldLooseBase.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldLooseBase.js\",\n        \"default\": \"./helpers/classPrivateFieldLooseBase.js\"\n      },\n      \"./helpers/classPrivateFieldLooseBase.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldLooseBase\": \"./helpers/esm/classPrivateFieldLooseBase.js\",\n    \"./helpers/classPrivateFieldGet\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldGet.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldGet.js\",\n        \"default\": \"./helpers/classPrivateFieldGet.js\"\n      },\n      \"./helpers/classPrivateFieldGet.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldGet\": \"./helpers/esm/classPrivateFieldGet.js\",\n    \"./helpers/classPrivateFieldSet\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldSet.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldSet.js\",\n        \"default\": \"./helpers/classPrivateFieldSet.js\"\n      },\n      \"./helpers/classPrivateFieldSet.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldSet\": \"./helpers/esm/classPrivateFieldSet.js\",\n    \"./helpers/classPrivateFieldDestructureSet\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldDestructureSet.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldDestructureSet.js\",\n        \"default\": \"./helpers/classPrivateFieldDestructureSet.js\"\n      },\n      \"./helpers/classPrivateFieldDestructureSet.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldDestructureSet\": \"./helpers/esm/classPrivateFieldDestructureSet.js\",\n    \"./helpers/classExtractFieldDescriptor\": [\n      {\n        \"node\": \"./helpers/classExtractFieldDescriptor.js\",\n        \"import\": \"./helpers/esm/classExtractFieldDescriptor.js\",\n        \"default\": \"./helpers/classExtractFieldDescriptor.js\"\n      },\n      \"./helpers/classExtractFieldDescriptor.js\"\n    ],\n    \"./helpers/esm/classExtractFieldDescriptor\": \"./helpers/esm/classExtractFieldDescriptor.js\",\n    \"./helpers/classStaticPrivateFieldSpecGet\": [\n      {\n        \"node\": \"./helpers/classStaticPrivateFieldSpecGet.js\",\n        \"import\": \"./helpers/esm/classStaticPrivateFieldSpecGet.js\",\n        \"default\": \"./helpers/classStaticPrivateFieldSpecGet.js\"\n      },\n      \"./helpers/classStaticPrivateFieldSpecGet.js\"\n    ],\n    \"./helpers/esm/classStaticPrivateFieldSpecGet\": \"./helpers/esm/classStaticPrivateFieldSpecGet.js\",\n    \"./helpers/classStaticPrivateFieldSpecSet\": [\n      {\n        \"node\": \"./helpers/classStaticPrivateFieldSpecSet.js\",\n        \"import\": \"./helpers/esm/classStaticPrivateFieldSpecSet.js\",\n        \"default\": \"./helpers/classStaticPrivateFieldSpecSet.js\"\n      },\n      \"./helpers/classStaticPrivateFieldSpecSet.js\"\n    ],\n    \"./helpers/esm/classStaticPrivateFieldSpecSet\": \"./helpers/esm/classStaticPrivateFieldSpecSet.js\",\n    \"./helpers/classStaticPrivateMethodGet\": [\n      {\n        \"node\": \"./helpers/classStaticPrivateMethodGet.js\",\n        \"import\": \"./helpers/esm/classStaticPrivateMethodGet.js\",\n        \"default\": \"./helpers/classStaticPrivateMethodGet.js\"\n      },\n      \"./helpers/classStaticPrivateMethodGet.js\"\n    ],\n    \"./helpers/esm/classStaticPrivateMethodGet\": \"./helpers/esm/classStaticPrivateMethodGet.js\",\n    \"./helpers/classStaticPrivateMethodSet\": [\n      {\n        \"node\": \"./helpers/classStaticPrivateMethodSet.js\",\n        \"import\": \"./helpers/esm/classStaticPrivateMethodSet.js\",\n        \"default\": \"./helpers/classStaticPrivateMethodSet.js\"\n      },\n      \"./helpers/classStaticPrivateMethodSet.js\"\n    ],\n    \"./helpers/esm/classStaticPrivateMethodSet\": \"./helpers/esm/classStaticPrivateMethodSet.js\",\n    \"./helpers/classApplyDescriptorGet\": [\n      {\n        \"node\": \"./helpers/classApplyDescriptorGet.js\",\n        \"import\": \"./helpers/esm/classApplyDescriptorGet.js\",\n        \"default\": \"./helpers/classApplyDescriptorGet.js\"\n      },\n      \"./helpers/classApplyDescriptorGet.js\"\n    ],\n    \"./helpers/esm/classApplyDescriptorGet\": \"./helpers/esm/classApplyDescriptorGet.js\",\n    \"./helpers/classApplyDescriptorSet\": [\n      {\n        \"node\": \"./helpers/classApplyDescriptorSet.js\",\n        \"import\": \"./helpers/esm/classApplyDescriptorSet.js\",\n        \"default\": \"./helpers/classApplyDescriptorSet.js\"\n      },\n      \"./helpers/classApplyDescriptorSet.js\"\n    ],\n    \"./helpers/esm/classApplyDescriptorSet\": \"./helpers/esm/classApplyDescriptorSet.js\",\n    \"./helpers/classApplyDescriptorDestructureSet\": [\n      {\n        \"node\": \"./helpers/classApplyDescriptorDestructureSet.js\",\n        \"import\": \"./helpers/esm/classApplyDescriptorDestructureSet.js\",\n        \"default\": \"./helpers/classApplyDescriptorDestructureSet.js\"\n      },\n      \"./helpers/classApplyDescriptorDestructureSet.js\"\n    ],\n    \"./helpers/esm/classApplyDescriptorDestructureSet\": \"./helpers/esm/classApplyDescriptorDestructureSet.js\",\n    \"./helpers/classStaticPrivateFieldDestructureSet\": [\n      {\n        \"node\": \"./helpers/classStaticPrivateFieldDestructureSet.js\",\n        \"import\": \"./helpers/esm/classStaticPrivateFieldDestructureSet.js\",\n        \"default\": \"./helpers/classStaticPrivateFieldDestructureSet.js\"\n      },\n      \"./helpers/classStaticPrivateFieldDestructureSet.js\"\n    ],\n    \"./helpers/esm/classStaticPrivateFieldDestructureSet\": \"./helpers/esm/classStaticPrivateFieldDestructureSet.js\",\n    \"./helpers/classCheckPrivateStaticAccess\": [\n      {\n        \"node\": \"./helpers/classCheckPrivateStaticAccess.js\",\n        \"import\": \"./helpers/esm/classCheckPrivateStaticAccess.js\",\n        \"default\": \"./helpers/classCheckPrivateStaticAccess.js\"\n      },\n      \"./helpers/classCheckPrivateStaticAccess.js\"\n    ],\n    \"./helpers/esm/classCheckPrivateStaticAccess\": \"./helpers/esm/classCheckPrivateStaticAccess.js\",\n    \"./helpers/classCheckPrivateStaticFieldDescriptor\": [\n      {\n        \"node\": \"./helpers/classCheckPrivateStaticFieldDescriptor.js\",\n        \"import\": \"./helpers/esm/classCheckPrivateStaticFieldDescriptor.js\",\n        \"default\": \"./helpers/classCheckPrivateStaticFieldDescriptor.js\"\n      },\n      \"./helpers/classCheckPrivateStaticFieldDescriptor.js\"\n    ],\n    \"./helpers/esm/classCheckPrivateStaticFieldDescriptor\": \"./helpers/esm/classCheckPrivateStaticFieldDescriptor.js\",\n    \"./helpers/decorate\": [\n      {\n        \"node\": \"./helpers/decorate.js\",\n        \"import\": \"./helpers/esm/decorate.js\",\n        \"default\": \"./helpers/decorate.js\"\n      },\n      \"./helpers/decorate.js\"\n    ],\n    \"./helpers/esm/decorate\": \"./helpers/esm/decorate.js\",\n    \"./helpers/classPrivateMethodGet\": [\n      {\n        \"node\": \"./helpers/classPrivateMethodGet.js\",\n        \"import\": \"./helpers/esm/classPrivateMethodGet.js\",\n        \"default\": \"./helpers/classPrivateMethodGet.js\"\n      },\n      \"./helpers/classPrivateMethodGet.js\"\n    ],\n    \"./helpers/esm/classPrivateMethodGet\": \"./helpers/esm/classPrivateMethodGet.js\",\n    \"./helpers/checkPrivateRedeclaration\": [\n      {\n        \"node\": \"./helpers/checkPrivateRedeclaration.js\",\n        \"import\": \"./helpers/esm/checkPrivateRedeclaration.js\",\n        \"default\": \"./helpers/checkPrivateRedeclaration.js\"\n      },\n      \"./helpers/checkPrivateRedeclaration.js\"\n    ],\n    \"./helpers/esm/checkPrivateRedeclaration\": \"./helpers/esm/checkPrivateRedeclaration.js\",\n    \"./helpers/classPrivateFieldInitSpec\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldInitSpec.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldInitSpec.js\",\n        \"default\": \"./helpers/classPrivateFieldInitSpec.js\"\n      },\n      \"./helpers/classPrivateFieldInitSpec.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldInitSpec\": \"./helpers/esm/classPrivateFieldInitSpec.js\",\n    \"./helpers/classPrivateMethodInitSpec\": [\n      {\n        \"node\": \"./helpers/classPrivateMethodInitSpec.js\",\n        \"import\": \"./helpers/esm/classPrivateMethodInitSpec.js\",\n        \"default\": \"./helpers/classPrivateMethodInitSpec.js\"\n      },\n      \"./helpers/classPrivateMethodInitSpec.js\"\n    ],\n    \"./helpers/esm/classPrivateMethodInitSpec\": \"./helpers/esm/classPrivateMethodInitSpec.js\",\n    \"./helpers/classPrivateMethodSet\": [\n      {\n        \"node\": \"./helpers/classPrivateMethodSet.js\",\n        \"import\": \"./helpers/esm/classPrivateMethodSet.js\",\n        \"default\": \"./helpers/classPrivateMethodSet.js\"\n      },\n      \"./helpers/classPrivateMethodSet.js\"\n    ],\n    \"./helpers/esm/classPrivateMethodSet\": \"./helpers/esm/classPrivateMethodSet.js\",\n    \"./helpers/identity\": [\n      {\n        \"node\": \"./helpers/identity.js\",\n        \"import\": \"./helpers/esm/identity.js\",\n        \"default\": \"./helpers/identity.js\"\n      },\n      \"./helpers/identity.js\"\n    ],\n    \"./helpers/esm/identity\": \"./helpers/esm/identity.js\",\n    \"./package\": \"./package.json\",\n    \"./package.json\": \"./package.json\",\n    \"./regenerator\": \"./regenerator/index.js\",\n    \"./regenerator/*.js\": \"./regenerator/*.js\",\n    \"./regenerator/\": \"./regenerator/\"\n  },\n  \"homepage\": \"https://babel.dev/docs/en/next/babel-runtime\",\n  \"license\": \"MIT\",\n  \"name\": \"@babel/runtime\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/babel/babel.git\",\n    \"directory\": \"packages/babel-runtime\"\n  },\n  \"type\": \"commonjs\",\n  \"version\": \"7.19.4\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"helpers\":{\"objectSpread2.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/@babel/runtime/helpers/objectSpread2.js                                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"objectWithoutProperties.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/@babel/runtime/helpers/objectWithoutProperties.js                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\",\n    \".mjs\",\n    \".jsx\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/modules/server.js\");\n\n/* Exports */\nPackage._define(\"modules\", exports, {\n  meteorInstall: meteorInstall\n});\n\n})();\n","servePath":"/packages/modules.js"}]